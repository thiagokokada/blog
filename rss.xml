<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kokada&#39;s blog</title>
    <link></link>
    <description># dd if=/dev/urandom of=/dev/brain0</description>
    <item>
      <title>Test</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-28/test.md</link>
      <description>&lt;p&gt;This is a test post.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-28/test.md</guid>
      <pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Quick bits: nix-shell is cursed</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</link>
      <description>&lt;p&gt;The other day I had to run a PHP project in my machine. I have no idea how PHP&#xA;ecosystem work, I just wanted to get it to run.&lt;/p&gt;&#xA;&lt;p&gt;The easiest way to get a script to run if you use Nix is to use &lt;code&gt;nix-shell&lt;/code&gt;. As&#xA;many of you probably know, you can add &lt;code&gt;nix-shell&lt;/code&gt; as a shebang in your scripts&#xA;to run them as &lt;code&gt;./script&lt;/code&gt;. This was a PHP script so I wanted to do the same.&#xA;Easy right?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;#!nix-shell -i php -p php83&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Fatal error: strict_types declaration must be the very first statement in the script in index.php on line 4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So it seems that &lt;code&gt;declare(strict_types=1)&lt;/code&gt; needs to be the first line in a PHP&#xA;script if used. I removed &lt;code&gt;declare(strict_types=1)&lt;/code&gt; and while the script works,&#xA;I don&#39;t have enough expertise in PHP to know if this would be safe or not.&lt;/p&gt;&#xA;&lt;p&gt;I decided to try something that initially looked really dumb:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;#!nix-shell -i php -p php83&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Works&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Wat? I mean, it is not dumb if it works, but this at least looks cursed.&lt;/p&gt;&#xA;&lt;p&gt;Eventually I found this&#xA;&lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446220517&#34;&gt;comment&lt;/a&gt; in a&#xA;Nix issue talking about cases where &lt;code&gt;nix-shell&lt;/code&gt; shebang doesn&#39;t work. It looks&#xA;like the classic case of a &lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446222206&#34;&gt;bug that becomes a&#xA;feature&lt;/a&gt;.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</guid>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Using GitHub as a (bad) blog platform</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</link>
      <description>&lt;p&gt;I finally started a new blog, thanks to the offer of&#xA;&lt;a href=&#34;https://gluer.org/&#34;&gt;@ratsclub&lt;/a&gt; to give me free access to&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;. But considering how small this blog&#xA;platform is supposed to be, I want to have at least somewhere to have a backup&#xA;of my posts. I know &lt;a href=&#34;https://mataroa.blog/&#34;&gt;Mataroa&lt;/a&gt;, the blog platform that&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt; runs, has automatic e-mail backups, but&#xA;I want something more reliable.&lt;/p&gt;&#xA;&lt;p&gt;I am writing all my posts in Markdown (the format that &lt;a href=&#34;https://1.mataroa.blog/guides/markdown/&#34;&gt;Mataroa&#xA;supports&lt;/a&gt;) files inside&#xA;&lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt; anyway, so why not store all my Markdown files in&#xA;Git? So this is what I did, I now have an unofficial mirror in&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;While I am here, why not to overcomplicate? Can I make an usable blog platform&#xA;from GitHub? And by that I don&#39;t mean GitHub pages, the repository itself. I&#xA;mean, it already renders Markdown files by default, so no need to do anything&#xA;in that space. To reach feature parity with&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;, I only need to have an index and RSS&#xA;(since comments are not supported anyway). No need for newsletter since GitHub&#xA;has a &lt;a href=&#34;https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/managing-subscriptions-for-activity-on-github/viewing-your-subscriptions&#34;&gt;watch&#xA;feature&lt;/a&gt;&#xA;already.&lt;/p&gt;&#xA;&lt;p&gt;After a couple of hours hacking a Python script, you can see the result of this&#xA;monstrosity &lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;here&lt;/a&gt;. The script, called&#xA;&lt;code&gt;gen_blog.py&lt;/code&gt;, is available at the same repository (here is a&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/c8986d1ab1b94c0986fd814629bb8eb4034fb6e7/gen_blog.py&#34;&gt;permalink&lt;/a&gt;).&#xA;It automatically generates an index at&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/README.md&#34;&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; with&#xA;each blog post and a&#xA;&lt;a href=&#34;https://raw.githubusercontent.com/thiagokokada/blog/main/rss.xml&#34;&gt;&lt;code&gt;rss.xml&lt;/code&gt;&lt;/a&gt;&#xA;file at the root of the repository.&lt;/p&gt;&#xA;&lt;p&gt;Instead of trying to explain the code, I am going to explain the general idea,&#xA;because I think that if you want to replicate this idea it is better to rewrite&#xA;it in a way that you understand. It shouldn&#39;t take more than 2 hours in any&#xA;decent programming language. But if you really want, the script itself is&#xA;licensed in &lt;a href=&#34;https://en.wikipedia.org/wiki/WTFPL&#34;&gt;WTFPL&lt;/a&gt; license. The code only&#xA;uses Python 3&#39;s standard library and should work in any relatively recent&#xA;version (anything newer than 3.9 should work).&lt;/p&gt;&#xA;&lt;p&gt;So the idea is basically to organise the repository and the Markdown files in a&#xA;easy way that makes it trivial to parse in a deterministic way. For example, my&#xA;repository is organised in the following way:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root&#xA;├── 2024-07-26&#xA;│   ├── 01-writing-nixos-tests-for-fun-and-profit.md&#xA;│   └── 02-using-github-as-a-bad-blog-platform.md &amp;lt;- this file&#xA;├── gen_blog.py&#xA;├── README.md&#xA;└── rss.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Each day that you write a new blog post will be on its own directory. This is&#xA;nice because Markdown files may include extra files than the posts themselves,&#xA;e.g.: images, and this organisation make it trivial to organise everything.&lt;/p&gt;&#xA;&lt;p&gt;Each post has its own Markdown file. I put a two digit number before each post,&#xA;to ensure that when publishing multiple posts at the same day I keep them in&#xA;the same order of publishing. But if you don&#39;t care about it, you can just name&#xA;the files whatever you want.&lt;/p&gt;&#xA;&lt;p&gt;Also, I am assuming that each Markdown file has a header starting with &lt;code&gt;# &lt;/code&gt;,&#xA;and that is the title of the blog post.&lt;/p&gt;&#xA;&lt;p&gt;Using the above organisation, I have this function that scrap the repository&#xA;and collect the necessary information to generate the index and RSS files:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def grab_posts(pwd: Path):&#xA;    posts = defaultdict(list)&#xA;&#xA;    for dir in sorted(pwd.iterdir(), reverse=True):&#xA;        # Ignore non-directories or hidden files&#xA;        if not dir.is_dir() or dir.name[0] == &amp;quot;.&amp;quot;:&#xA;            continue&#xA;&#xA;        # Try to parse date from directory name&#xA;        try:&#xA;            date = datetime.strptime(dir.name, &amp;quot;%Y-%m-%d&amp;quot;)&#xA;        except ValueError:&#xA;            print(f&amp;quot;WARN: ignoring non-date directory: {dir}&amp;quot;, file=sys.stderr)&#xA;            continue&#xA;&#xA;        # Iterate between the files in the date directory&#xA;        for post in sorted(dir.iterdir(), reverse=True):&#xA;            # Ignore non-markdown files or hidden files (draft)&#xA;            if not post.suffix == &amp;quot;.md&amp;quot; or post.name[0] == &amp;quot;.&amp;quot;:&#xA;                continue&#xA;&#xA;            # Grab the first H1 section to parse as title&#xA;            text = post.read_text()&#xA;            mTitle = re.match(r&amp;quot;# (?P&amp;lt;title&amp;gt;.*)\r?\n&amp;quot;, text)&#xA;            if mTitle and (title := mTitle.groupdict().get(&amp;quot;title&amp;quot;)):&#xA;                posts[date].append({&amp;quot;title&amp;quot;: title, &amp;quot;file&amp;quot;: str(post)})&#xA;            else:&#xA;                print(f&amp;quot;WARN: did not find title for file: {post}&amp;quot;, file=sys.stderr)&#xA;&#xA;    return posts&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Some interesting tidbits: if a Markdown file has a &lt;code&gt;.&lt;/code&gt; at the start I assume it&#xA;is a draft post, and ignore it from my scrapper. I added a bunch of &lt;code&gt;WARN&lt;/code&gt;&#xA;prints to make sure that the me in the future doesn&#39;t do anything dumb. Also,&#xA;sorting in reverse since reverse chronological order is the one most people&#xA;expect in blogs (i.e.: more recent blog posts at top).&lt;/p&gt;&#xA;&lt;p&gt;After running the function above, I have a resulting dictionary that I can use&#xA;to generate either a &lt;code&gt;README.md&lt;/code&gt; file or Markdown:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen_readme(posts):&#xA;    titles = []&#xA;&#xA;    for date, dayPosts in posts.items():&#xA;        for post in dayPosts:&#xA;            # This creates a relative link to the Markdown file, .e.g.:&#xA;            # ./02-using-github-as-a-bad-blog-platform.md&#xA;            link = os.path.join(&amp;quot;.&amp;quot;, post[&amp;quot;file&amp;quot;])&#xA;            # This formats the title, e.g.:&#xA;            # - [Using GitHub as a (bad) blog platform](./2024-07-26/02-using-github-as-a-bad-blog-platform.md) - 2024-07-26&#xA;            title = date.strftime(f&amp;quot;- [{post[&#39;title&#39;]}]({link}) - %Y-%m-%d&amp;quot;)&#xA;            # This appends to the list to generate the content later&#xA;            titles.append(title)&#xA;&#xA;    # README_TEMPLATE is a string with the static part of the README&#xA;    print(README_TEMPLATE.format(posts=&amp;quot;\n&amp;quot;.join(titles)))&#xA;&#xA;&#xA;def gen_rss(posts):&#xA;    # Got most of the specification from here:&#xA;    # https://www.w3schools.com/XML/xml_rss.asp&#xA;    rss = ET.Element(&amp;quot;rss&amp;quot;, version=&amp;quot;2.0&amp;quot;)&#xA;&#xA;    # Here are the RSS metadata for the blog itself&#xA;    channel = ET.SubElement(rss, &amp;quot;channel&amp;quot;)&#xA;    ET.SubElement(channel, &amp;quot;title&amp;quot;).text = &amp;quot;kokada&#39;s blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;link&amp;quot;).text = &amp;quot;https://github.com/thiagokokada/blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;description&amp;quot;).text = &amp;quot;dd if=/dev/urandom of=/dev/brain0&amp;quot;&#xA;&#xA;    # You create one item for each blog post&#xA;    for date, dayPost in posts.items():&#xA;        for post in dayPost:&#xA;            item = ET.SubElement(channel, &amp;quot;item&amp;quot;)&#xA;            link = urljoin(RSS_POST_LINK_PREFIX, post[&amp;quot;file&amp;quot;])&#xA;            ET.SubElement(item, &amp;quot;title&amp;quot;).text = post[&amp;quot;title&amp;quot;]&#xA;            ET.SubElement(item, &amp;quot;guid&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;link&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;pubDate&amp;quot;).text = date.strftime(&#39;%a, %d %b %Y %H:%M:%S GMT&#39;)&#xA;&#xA;    # Generate the XML and indent&#xA;    tree = ET.ElementTree(rss)&#xA;    ET.indent(tree, space=&amp;quot;\t&amp;quot;, level=0)&#xA;    tree.write(&amp;quot;rss.xml&amp;quot;, xml_declaration=True, encoding=&amp;quot;UTF-8&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To publish a new Post, a basically write a Markdown file, run&#xA;&lt;code&gt;./gen_readme.py &amp;gt; README.md&lt;/code&gt; at the root of the repository, and see the magic&#xA;happens.&lt;/p&gt;&#xA;&lt;p&gt;It works much better than I initially antecipated. The &lt;code&gt;README.md&lt;/code&gt; is properly&#xA;populated with the titles and links. The RSS is kind empty since it has no&#xA;description, but it seems to work fine (at least in&#xA;&lt;a href=&#34;https://www.inoreader.com/&#34;&gt;Inoreader&lt;/a&gt;, my RSS reader of choice). I can&#xA;probably fill the post description with more information if I really want, but&#xA;it is enough for now (update: it is working now, you just need to render the&#xA;Markdown as HTML and escape the tags;&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/9506051cc3d49f203304174b335ff62de9d17a05/gen_blog.py&#34;&gt;permalink&lt;/a&gt;&#xA;for the updated script). Not sure who is that interested in my writing that&#xA;will want to use this RSS feed instead the one available in&#xA;&lt;a href=&#34;https://kokada.capivaras.dev/rss/&#34;&gt;capivaras.dev&lt;/a&gt; anyway.&lt;/p&gt;&#xA;&lt;p&gt;Also, while I am using GitHub here, the same idea would work in GitLab, Gitea,&#xA;sr.ht or whatever. As long as your source hub supports Markdown files it should&#xA;work.&lt;/p&gt;&#xA;&lt;p&gt;So that is it. I am not saying this is a good idea for your primary blog&#xA;platform or whatever, and I still prefer to publish to a platform that doesn&#39;t&#xA;track users or have tons of JavaScript or whatever. But if you want a backup of&#xA;your posts and you are already writing Markdown anyway, well, there are worse&#xA;ways to do it I think.&lt;/p&gt;&#xA;&lt;p&gt;Update: I rewrote the script again using Go&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/3ece3853e7dd32977e7ec5238d2955e530ca4beb/blog.go&#34;&gt;permalink&lt;/a&gt;).&#xA;The reason for it is because when I started rendering Markdown (for&#xA;descriptions) the Python version got quite slow (not the fault of Python&#xA;itself, mostly because of the usage of &lt;code&gt;nix-shell&lt;/code&gt; to manage dependencies;&#xA;something that Go doesn&#39;t need). Took about half an hour, showing how easy it&#xA;is to do the same.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Writing NixOS tests for fun and profit</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</link>
      <description>&lt;p&gt;I recently started a &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go&#34;&gt;new side&#xA;project&lt;/a&gt; writing an IPC library in&#xA;Go for &lt;a href=&#34;https://hyprland.org/&#34;&gt;Hyprland&lt;/a&gt;, a Window Manager for Wayland.&lt;/p&gt;&#xA;&lt;p&gt;Once I got past the Work-in-Progress phase, I realise I had an issue: I wrote&#xA;some tests, but I was running then inside my system running Hyprland. And the&#xA;tests themselves were annoying: since they send commands to the current running&#xA;Hyprland instance, I was having programs being opened and settings being&#xA;changed, because this was the only way to have a reasonable good confidence&#xA;that what I was doing was correct. So I need to do like any good developer and&#xA;implement a CI, but how?&lt;/p&gt;&#xA;&lt;p&gt;One approach would be to create something like a mock client and test against&#xA;my mock. Since this mock wouldn&#39;t need a running Hyprland instance the tests&#xA;could run everywhere (even in non-Linux systems!), but they wouldn&#39;t be much&#xA;useful. Mocks are great for testing business logic, but not really for making&#xA;sure everything is working correctly.&lt;/p&gt;&#xA;&lt;p&gt;I need something more akin to an integration test, but this is tricky. It is&#xA;not like I am doing integration with e.g.: PostgreSQL that has thousands of&#xA;libraries available to make integration tests easier, I am doing integration&#xA;with a Window Manager that is a moving target with multiple breaking changes in&#xA;each release. And this is where NixOS tests enter, a way to run tests inside&#xA;Virtual Machines configured in Nix.&lt;/p&gt;&#xA;&lt;p&gt;I am a long time NixOS user and commiter, but I never wrote a NixOS test&#xA;outside of &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;nixpkgs&lt;/a&gt; itself. However I knew&#xA;it was possible, and after doing a quick reading of the &lt;a href=&#34;https://wiki.nixos.org/wiki/NixOS_VM_tests&#34;&gt;Wiki&#xA;entry&lt;/a&gt; about it, I was ready to&#xA;start.&lt;/p&gt;&#xA;&lt;p&gt;The first part is to call &lt;code&gt;pkgs.testers.runNixOSTest&lt;/code&gt; and configure the machine&#xA;as any other NixOS system, e.g.:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ pkgs, ... }:&#xA;pkgs.testers.runNixOSTest {&#xA;  name = &amp;quot;hyprland-go&amp;quot;;&#xA;&#xA;  nodes.machine =&#xA;    { config, pkgs, lib, ... }:&#xA;    {&#xA;      # bootloader related configuration&#xA;      boot.loader.systemd-boot.enable = true;&#xA;      boot.loader.efi.canTouchEfiVariables = true;&#xA;&#xA;      # enable hyprland&#xA;      programs.hyprland.enable = true;&#xA;&#xA;      # create a user called alice&#xA;      users.users.alice = {&#xA;        isNormalUser = true;&#xA;      };&#xA;&#xA;      # add some extra packages that we need during tests&#xA;      environment.systemPackages = with pkgs; [ go kitty ];&#xA;&#xA;      # auto login as alice&#xA;      services.getty.autologinUser = &amp;quot;alice&amp;quot;;&#xA;&#xA;      # configure VM, increase memory and CPU and enable OpenGL via LLVMPipe&#xA;      virtualisation.qemu = {&#xA;        options = [&#xA;          &amp;quot;-smp 2&amp;quot;&#xA;          &amp;quot;-m 4G&amp;quot;&#xA;          &amp;quot;-vga none&amp;quot;&#xA;          &amp;quot;-device virtio-gpu-pci&amp;quot;&#xA;        ];&#xA;      };&#xA;&#xA;      # Start hyprland at login&#xA;      programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;;&#xA;    };&#xA;&#xA;  testScript = &amp;quot;start_all()&amp;quot;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A few details that I want to bring to attention. The first one is how easy it&#xA;is to setup things like a normal user account, add some extra packages we need&#xA;for testing, add Hyprland itself and configure auto-login. I have no idea how&#xA;painful it would be to automatise all those steps in e.g.: Ansible, but here we&#xA;are in a few lines of Nix code. This is, of course, thanks to all the&#xA;contributors to nixpkgs that implement something that help their own use case,&#xA;but once combined make it greater than the sum of the parts.&lt;/p&gt;&#xA;&lt;p&gt;Second is something that I took a while to figure out: how to enable GPU&#xA;acceleration inside the VM. You see, Hyprland, different from other Window&#xA;Managers, requires OpenGL support. This is basically why the flag &lt;code&gt;-device virtio-gpu-pci&lt;/code&gt; is in &lt;code&gt;virtualisation.qemu.options&lt;/code&gt;, this enables OpenGL&#xA;rendering via LLVMPipe, that while being slow since it is rendered in CPU, is&#xA;sufficient for this case.&lt;/p&gt;&#xA;&lt;p&gt;Putting the above code inside a&#xA;&lt;a href=&#34;https://wiki.nixos.org/wiki/Flakes&#34;&gt;&lt;code&gt;flake.nix&lt;/code&gt;&lt;/a&gt; for reproducibility, I had&#xA;something similar to:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  description = &amp;quot;Hyprland&#39;s IPC bindings for Go&amp;quot;;&#xA;&#xA;  inputs = {&#xA;    nixpkgs.url = &amp;quot;github:NixOS/nixpkgs/nixos-unstable&amp;quot;;&#xA;  };&#xA;&#xA;  outputs = { nixpkgs, ... }:&#xA;    {&#xA;      checks.x86_64-linux =&#xA;        let&#xA;          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };&#xA;        in&#xA;        {&#xA;          testVm = pkgs.testers.runNixOSTest {&#xA;            # the code above&#xA;          };&#xA;        }&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I can now run &lt;code&gt;nix build .#checks.x86_64-linux.testVm -L&lt;/code&gt; to build and run the&#xA;VM. However it is not really useful right now, since we didn&#39;t add any useful&#xA;code in &lt;code&gt;testScript&lt;/code&gt;, the core of the NixOS test framework. We can also run&#xA;&lt;code&gt;nix build .#checks.x86_64-linux.testVm.driverInteractive&lt;/code&gt; and&#xA;&lt;code&gt;./result/bin/nixos-test-driver&lt;/code&gt;: this will start a Python console where we can&#xA;manually play with the VM (try typing &lt;code&gt;start_all()&lt;/code&gt; for example).&lt;/p&gt;&#xA;&lt;p&gt;The &lt;code&gt;testScript&lt;/code&gt; is a sequence of Python statements that perform various&#xA;actions, such as starting VMs, executing commands in the VMs, and so on. More&#xA;about it in the official&#xA;&lt;a href=&#34;https://nixos.org/manual/nixos/stable/index.html#sec-nixos-tests&#34;&gt;documentation&lt;/a&gt;.&#xA;For our case we can start with something like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;    testScript = /* python */ &#39;&#39;&#xA;      start_all()&#xA;&#xA;      machine.wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&#xA;      machine.wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The first statement, &lt;code&gt;start_all()&lt;/code&gt;, starts all VMs, in this case we have only&#xA;one, called &lt;code&gt;machine&lt;/code&gt;. We send two further commands to &lt;code&gt;machine&lt;/code&gt;:&#xA;&lt;code&gt;wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&lt;/code&gt; and&#xA;&lt;code&gt;wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The first command waits until systemd&#39;s &lt;code&gt;multi-user.target&lt;/code&gt; is ready, a good&#xA;way to ensure that the system is ready for further commands. The second one we&#xA;wait for a file called &lt;code&gt;test-finished&lt;/code&gt; to appear in Alice&#39;s &lt;code&gt;$HOME&lt;/code&gt; (basically,&#xA;a canary), but how can we generate this file?&lt;/p&gt;&#xA;&lt;p&gt;Remember that we added &lt;code&gt;programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;&lt;/code&gt;, that&#xA;automatically starts Hyprland when Alice logs in. We need to modify that&#xA;command to run the Go tests from our library. The good thing is that Hyprland&#xA;configuration file supports a&#xA;&lt;a href=&#34;https://wiki.hyprland.org/Configuring/Keywords/#executing&#34;&gt;&lt;code&gt;exec-once&lt;/code&gt;&lt;/a&gt;&#xA;command that runs a command during Hyprland launch. We can abuse this to launch&#xA;a terminal emulator and run our tests:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  programs.bash.loginShellInit =&#xA;    let&#xA;      testScript = pkgs.writeShellScript &amp;quot;hyprland-go-test&amp;quot; &#39;&#39;&#xA;        set -euo pipefail&#xA;&#xA;        trap &#39;echo $? &amp;gt; $HOME/test-finished&#39; EXIT # creates the canary when the script finishes&#xA;&#xA;        cd ${./.} # go to the library directory&#xA;        go test -v ./... &amp;gt; $HOME/test.log 2&amp;gt;&amp;amp;1 # run Go tests&#xA;      &#39;&#39;;&#xA;      hyprlandConf = pkgs.writeText &amp;quot;hyprland.conf&amp;quot; &#39;&#39;&#xA;        exec-once = kitty sh -c ${testScript}&#xA;      &#39;&#39;;&#xA;    in &#39;&#39;&#xA;      Hyprland --config ${hyprlandConf}&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So we are basically creating a custom Hyprland config that starts a&#xA;&lt;a href=&#34;https://sw.kovidgoyal.net/kitty/&#34;&gt;Kitty&lt;/a&gt; terminal emulator, that then launches&#xA;a shell script that runs the test. Since we have no way to get the results of&#xA;the test, we pipe the output to a file that we can collect later (e.g.:&#xA;&lt;code&gt;machine.succeded(&amp;quot;cat /home/alice/test.log&amp;quot;)&lt;/code&gt;). And once the script exit, we&#xA;create the canary file &lt;code&gt;$HOME/test-finished&lt;/code&gt;, that allows the &lt;code&gt;testScript&lt;/code&gt;&#xA;knows that the test finished and it can destroy the VM safely.&lt;/p&gt;&#xA;&lt;p&gt;If you want to take a look at the final result, it is&#xA;&lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/blob/v0.0.1/flake.nix&#34;&gt;here&lt;/a&gt;. This&#xA;tests run in any Linux machine that supports KVM, and also works in &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/actions/workflows/nix.yaml&#34;&gt;GitHub&#xA;Actions&lt;/a&gt;&#xA;thanks to the the&#xA;&lt;a href=&#34;https://github.com/DeterminateSystems/nix-installer-action&#34;&gt;nix-installer-action&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;And now I have a proper CI pipeline in a way that I never imagined would be&#xA;possible, especially considering how simple it was.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>