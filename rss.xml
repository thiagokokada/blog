<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kokada&#39;s blog</title>
    <link></link>
    <description># dd if=/dev/urandom of=/dev/brain0</description>
    <item>
      <title>First impressions: FPGBC</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-30/01-first-impressions-fpgbc.md</link>
      <description>&lt;p&gt;Here is something for nostalgia: I just put together a &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_Boy_Color&#34;&gt;Game Boy&#xA;Color&lt;/a&gt; made of completely new&#xA;parts for a friend: here is the&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;FPGBC&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;em&gt;FP&lt;/em&gt; part of the name comes from&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Field-programmable_gate_array&#34;&gt;FPGA&lt;/a&gt;, because&#xA;instead of software emulation this device use FPGA to reproduce the device.&#xA;While I am not convinced that FPGA is necessary more accurate than a good&#xA;software emulator, one advantage of FPGA is the (possible) lower input latency&#xA;thanks to the avoidance of complexity to handle the user input (e.g.: the&#xA;Operational System). A quick playthrough against &lt;a href=&#34;https://en.wikipedia.org/wiki/Motocross_Maniacs&#34;&gt;Motocross&#xA;Maniacs&lt;/a&gt; seems to be fine, but&#xA;I can&#39;t see much difference from my &lt;a href=&#34;https://retrogamecorps.com/2022/05/15/miyoo-mini-v2-guide/&#34;&gt;Miyoo&#xA;Mini+&lt;/a&gt; (I will do&#xA;more comparisons between the two devices later), that is a software emulation&#xA;device.&lt;/p&gt;&#xA;&lt;p&gt;But I think focusing in accuracy is wrong, the main reason of getting a device&#xA;like this one is for nostalgia, and this definitely hit the mark. The quality&#xA;of the case is as good as I remember the original, and most of the details are&#xA;replicate perfectly, including reproduction stickers in the back of the device.&#xA;The only differences that I can find is the usage of USB-C port for charging in&#xA;place of the barrel jack power adapter (thanks!), and the fact that the screen&#xA;bezels are smaller compared to the original (because the screen is bigger) and&#xA;doesn&#39;t include the Game Boy Color logo (that is fine in my opinion, since it&#xA;would look weird in the fine bezels). It even has a supposedly working &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_Link_Cable&#34;&gt;Link&#xA;Cable&lt;/a&gt; (I don&#39;t have another&#xA;Game Boy to test). Sadly it is missing the infrared sensor, but the usage of&#xA;that was pretty limited anyway.&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://capivaras.dev/images/1545d11f.jpeg&#34;&gt;&lt;img src=&#34;https://capivaras.dev/images/1545d11f.jpeg&#34; alt=&#34;FPGBC running Tetris.&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://capivaras.dev/images/6746624f.jpeg&#34;&gt;&lt;img src=&#34;https://capivaras.dev/images/6746624f.jpeg&#34; alt=&#34;Back of FPGBC. It includes even reproduction stickers of the original.&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;So how well does it work? I can&#39;t say for sure. I don&#39;t have any original games&#xA;with me, so I am relying in backups and a&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Flashcard&#34;&gt;flashcard&lt;/a&gt; for now. Many games that I&#xA;tested works fine, a few of them have graphical issues that can be fixed in the&#xA;menu (more about it later), and some of them doesn&#39;t boot. But I don&#39;t know if&#xA;the issue with the games not booting are because of the roms, the flashcard or&#xA;the device itself.&lt;/p&gt;&#xA;&lt;p&gt;By the way, the flashcard I am using is a cheap knockoff of an &lt;a href=&#34;https://gbatemp.net/review/everdrive-gb.141/&#34;&gt;Everdrive&#xA;GB&lt;/a&gt;. This FPGBC came with&#xA;firmware v1.09, while there is an update available for v1.10 in the&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;website&lt;/a&gt;. I had an weird issue in&#xA;the new firmware where no games would boot with this knockoff Everdrive so I&#xA;had to go back to v1.09, but again, I am not sure if the issue was fact that I&#xA;am using a knockoff device or this would happen with an original Everdrive GB.&#xA;If you are going to buy a proper Everdrive, you probably wouldn&#39;t get a&#xA;Everdrive GB anyway since it is discontinued, and it seems the &lt;a href=&#34;https://www.reddit.com/r/Gameboy/comments/1atwjh3/fpgbc_everdrive_compatibility/&#34;&gt;newer&#xA;versions&lt;/a&gt;&#xA;have better compatibility with FPGBC.&lt;/p&gt;&#xA;&lt;p&gt;Sadly that the update didn&#39;t work, since there is this&#xA;&lt;a href=&#34;https://github.com/makhowastaken/GWGBC_FW&#34;&gt;repository&lt;/a&gt; that patches the&#xA;firmware to boot the original logo instead of the ugly FPGBC one. And yes, for&#xA;some reason the v1.09 firmware from this repository still doesn&#39;t work with my&#xA;knockoff Everdrive.&lt;/p&gt;&#xA;&lt;p&gt;About the features of the device: if you press the volume button (yes, you can&#xA;press it now), it opens the following menu:&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://capivaras.dev/images/4391c351.jpeg&#34;&gt;&lt;img src=&#34;https://capivaras.dev/images/4391c351.jpeg&#34; alt=&#34;FPGBC menu.&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;The first 2 features are the LCD backlight and volume. I didn&#39;t talk about&#xA;those, but the LCD screen seems to be IPS, and the quality is really good, and&#xA;also looks bright enough to play even under bad lightining conditions. And the&#xA;speaker has good quality, the sound is better than I remember, but sadly the&#xA;maximum volume is kind low. Still should be enough for playing in a quiet room.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;DISPMOD&lt;/code&gt; is probably the most controversial option: it allow you to set which&#xA;scale you want. Anything with &lt;code&gt;EMU&lt;/code&gt; at the end means emulating the original&#xA;colors, and as far I remember it gets really close. You can also chose betwen&#xA;&lt;code&gt;X4&lt;/code&gt;, &lt;code&gt;X4P&lt;/code&gt; and &lt;code&gt;FUL&lt;/code&gt;, the last one is the one shown in the photos where the&#xA;image fills the whole screen at the cost of non-integer scaling. &lt;code&gt;X4&lt;/code&gt; is&#xA;integer scaling, however the image doesn&#39;t fill the whole screen. The &lt;code&gt;X4P&lt;/code&gt;&#xA;also includes a pixel effect that makes the image closer than the original&#xA;screen. It actually looks good, but the fact that I chose a white border for&#xA;this FPGBC makes the border really distracting. Maybe the black one is a better&#xA;choice if you want integer scale.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;CORE&lt;/code&gt; is simple: you can choose between &lt;code&gt;GB&lt;/code&gt; (Game Boy) or &lt;code&gt;GBC&lt;/code&gt; (Game Boy&#xA;Color). For those who don&#39;t know, you can run Game Boy games in Game Boy Color&#xA;and they will be automatically colorised. Some people don&#39;t like this and&#xA;prefer the colors of &lt;code&gt;GB&lt;/code&gt;, so you have this option. The &lt;code&gt;GB_PALETTE&lt;/code&gt; allows you&#xA;to chose the color in GB mode, for example, the green-ish colors from the&#xA;original Game Boy or the blue-ish colors from &lt;a href=&#34;https://nintendo.fandom.com/wiki/Game_Boy_Light&#34;&gt;Game Boy&#xA;Light&lt;/a&gt;. And yes, you can&#xA;choose the color palette for Game Boy games running in &lt;code&gt;GBC&lt;/code&gt; mode by pressing a&#xA;&lt;a href=&#34;https://gbstudiocentral.com/tips/game-boy-color-modes/&#34;&gt;button combination&lt;/a&gt; at&#xA;the boot screen, but it seems not working in my unit and again, not sure if the&#xA;fault is my knockoff Everdrive.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;FRAME_MIX&lt;/code&gt; basically is an option that makes some effects, like transparency&#xA;in &lt;a href=&#34;https://en.wikipedia.org/wiki/Wave_Race&#34;&gt;Wave Race&lt;/a&gt;, to work at the cost of&#xA;introducing blurriness. The reason for this is that those effects depends in&#xA;the fact that the Game Boy screen was slow refresh, so you could rely on it by&#xA;rapidly changing pixels to create some interesting effects, but sadly those&#xA;effects doesn&#39;t work well in modern displays.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;GB_CLRFIX&lt;/code&gt; is the option I mentioned before, where some Game Boy games just&#xA;get completely wrong colors for some reason, e.g.: &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Addams_Family_(video_game)&#34;&gt;The Addams&#xA;Family&lt;/a&gt;. Turning&#xA;on fixes those games, but I am not sure if this option breaks other games.&lt;/p&gt;&#xA;&lt;p&gt;Finally, &lt;code&gt;SPD&lt;/code&gt; allows you to increase or decrease the CPU clock, slowing or&#xA;speeding up the games (including the sound). The result can be hilarious, so I&#xA;think this is a nice addition to the features. Sadly you can&#39;t know what the&#xA;default speed is, so you need to rely on sound to adjust back to the default.&lt;/p&gt;&#xA;&lt;p&gt;So in the end, can I recommend a FPGBC? I am not sure. If you want a device to&#xA;play games, I still think something like a Miyoo Mini+ is a better choice. Not&#xA;only you will have access to more games from different platforms, you also&#xA;don&#39;t need to rely on flashcards or cartridges. Also it has way more features&#xA;than FPGBC, like wireless multiplayer,&#xA;&lt;a href=&#34;https://retroachievements.org/&#34;&gt;RetroArchivements&lt;/a&gt; and save states.&lt;/p&gt;&#xA;&lt;p&gt;But the actual reason to get a FPGBC is nostalgia, and for that I think the&#xA;FPGBC is difficult to beat. The price of the &lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;kit to&#xA;assemble&lt;/a&gt; ($69.90) is cheaper than&#xA;most Game Boy&#39;s in good condition you can find in eBay, and you get for that&#xA;price a rechargable battery, an amazing quality screen, the PCB and the&#xA;speaker. You need to buy separately the case and the buttons, but in total you&#xA;will still end up paying less, and allows you to fully customise your build.&#xA;And the result device is not only in mint condition, it is really convenient&#xA;too: recharging batteries (via USB-C even) is much more convenient than buying&#xA;AA batteries, and the screen not only is better but it even has backlight. You&#xA;can also a fully built console for&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-console&#34;&gt;$99.00&lt;/a&gt;, but you have less&#xA;options of customisation.&lt;/p&gt;&#xA;&lt;p&gt;This is the classic case of do what I say, don&#39;t do what I do. This FPGBC is a&#xA;gift, and I will buy another one soon. Can&#39;t wait to play &lt;a href=&#34;https://en.wikipedia.org/wiki/Pok%C3%A9mon_Gold_and_Silver&#34;&gt;Pokémon&#xA;Gold&lt;/a&gt; in (almost)&#xA;original hardware again.&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://capivaras.dev/images/7f34caba.jpeg&#34;&gt;&lt;img src=&#34;https://capivaras.dev/images/7f34caba.jpeg&#34; alt=&#34;The kit before assemble.&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-30/01-first-impressions-fpgbc.md</guid>
      <pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Go, a reasonable good language</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-29/02-go-a-reasonable-good-language.md</link>
      <description>&lt;p&gt;Go was one of the languages that I always was interested to learn, but never&#xA;got the hang of it. I first got interested in the language when I was in my&#xA;first job, between 2016-2018. At the time the language was a completely&#xA;different beast: no modules, no generics, no easy way to error wrap yet, etc.&lt;/p&gt;&#xA;&lt;p&gt;Go forward 2023 (no pun indented), I wrote my &lt;a href=&#34;https://github.com/thiagokokada/twenty-twenty-twenty/&#34;&gt;first project in&#xA;Go&lt;/a&gt;, wrote some scripts&#xA;at &lt;code&gt;$CURRENT_JOB&lt;/code&gt; in the language, and now wrote &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/&#34;&gt;my first&#xA;library&lt;/a&gt;. I am also writing more&#xA;&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/blob/8c559527ed12e1d4f57a3fc5c72630b956f4c290/home-manager/desktop/wayland/hyprland/hyprtabs/hyprtabs.go&#34;&gt;scripts&lt;/a&gt;&#xA;in the language, where I would prefer to use Bash or Python before. Heck, even&#xA;this blog is automatically published with a &lt;a href=&#34;https://kokada.capivaras.dev/blog/quick-bits-why-you-should-automate-everything/&#34;&gt;Go&#xA;script&lt;/a&gt;,&#xA;that used to be a &lt;a href=&#34;https://kokada.capivaras.dev/blog/using-github-as-a-bad-blog-platform/&#34;&gt;Python&#xA;one&lt;/a&gt;&#xA;before. I can say that nowadays it is another language in my toolbox, and while&#xA;it is still a love and hate relationship, recently it is more about love and&#xA;less about hate.&lt;/p&gt;&#xA;&lt;p&gt;The points that I love about Go is probably obvious for some, but still&#xA;interesting to talk about anyway. The fact that the language generates static&#xA;binaries by default and have fast compilation times is something that I&#xA;apreciate since I first heard about the language, and now that I am using the&#xA;language frequently are points I appreciate even more. Something about getting&#xA;almost instant feedback after changing a line of code and running &lt;code&gt;go run&lt;/code&gt;&#xA;(even with its quirks) are great for the developer experience. This is the main&#xA;reason why I am using the language more frequently for scripts.&lt;/p&gt;&#xA;&lt;p&gt;Then we have the fast startup times. I am kind of sensitive to latency,&#xA;especially of command line utilities that need to answer fast when I expect&#xA;them to be fast (e.g.: &lt;code&gt;foo --help&lt;/code&gt;). This is one part where I could have&#xA;issues in Python, especially for more complex programs, but in Go it is rarely&#xA;an issue.&lt;/p&gt;&#xA;&lt;p&gt;Modules are also fantastic. It is not without its weirdness (like everything in&#xA;Go ecossystem), but the fact that it is so easy to add and manage dependencies&#xA;in a project using only the &lt;code&gt;go&lt;/code&gt; CLI is great. I also like that it generates a&#xA;hash of every dependency, make it reproducible (well, probably not at Nix&#xA;level, but still reproducible).&lt;/p&gt;&#xA;&lt;p&gt;Since I started to talk about &lt;code&gt;go&lt;/code&gt; CLI, what a great tool! The fact that you&#xA;can manage dependencies, generate documentation, format code, lint, run tests,&#xA;etc., all with just the &amp;quot;compiler&amp;quot; for the language is excelent. Still probably&#xA;one of the best developer experiences I know in any programming language (maybe&#xA;only rivaled by &lt;a href=&#34;https://ziglang.org/&#34;&gt;Zig&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;I will not even talk about the things that everyone talks about Go, like&#xA;&lt;a href=&#34;https://go.dev/doc/effective_go#goroutines&#34;&gt;goroutines&lt;/a&gt;, because I just don&#39;t&#xA;think I can add anything interesting to the topic.&lt;/p&gt;&#xA;&lt;p&gt;Now for the parts that I like less, the test part still quirks me that it is&#xA;not based in assertions, but thankfully it is easy to write assertions with&#xA;generics nowadays:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Equal[T comparable](t *testing.T, got, want T) {&#xA;&#x9;t.Helper()&#xA;&#x9;if got != want {&#xA;&#x9;&#x9;t.Errorf(&amp;quot;got: %#v, want: %#v&amp;quot;, got, want)&#xA;&#x9;}&#xA;}&#xA;&#xA;func GreaterOrEqual[T cmp.Ordered](t *testing.T, actual, expected T) {&#xA;&#x9;t.Helper()&#xA;&#x9;if actual &amp;lt; expected {&#xA;&#x9;&#x9;t.Errorf(&amp;quot;got: %v; want: &amp;gt;=%v&amp;quot;, actual, expected)&#xA;&#x9;}&#xA;}&#xA;&#xA;// etc...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Just one of those things that I end up re-writing in every project. Yes, I know&#xA;about &lt;a href=&#34;https://github.com/stretchr/testify&#34;&gt;testify&lt;/a&gt; and other assertion&#xA;libraries, but quoting &lt;a href=&#34;https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;amp;t=568s&#34;&gt;Rob&#xA;Pike&lt;/a&gt; here, &amp;quot;a little&#xA;copying is better than a little dependency&amp;quot;. As long the code you write is&#xA;trivial, it is better to duplicate the code than try to import a dependency.&lt;/p&gt;&#xA;&lt;p&gt;About another piece of code that generics allows me to write and I always end&#xA;up re-writing in every project is the &lt;code&gt;must*&lt;/code&gt; family of functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func must(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func must1[T any](v T, err error) T {&#xA;&#x9;must(err)&#xA;&#x9;return v&#xA;}&#xA;&#xA;// must2, must3, etc...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Those functions are so useful, especially for scripts where I generally don&#39;t&#xA;want to handle each error: if I have an error, I want the program to halt and&#xA;print a stack trace (exactly as I would have with a language with exceptions).&#xA;It basically allow me to convert code from:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;contents, err := os.ReadFile(&amp;quot;file&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;contents := must1(os.ReadFile(&amp;quot;file&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This brings Go closer to Python to me, and I think for scripts this is&#xA;something great.&lt;/p&gt;&#xA;&lt;p&gt;Finally, for the things that I hate, well the biggest one currently is the lack&#xA;of nullability (or in Go terms,&#xA;&lt;a href=&#34;https://github.com/golang/go/issues/49202&#34;&gt;nillability&lt;/a&gt;). After using&#xA;languages that has it, like Kotlin, or even something like&#xA;&lt;a href=&#34;https://www.mypy-lang.org/&#34;&gt;mypy&lt;/a&gt;, this is one of those things that completely&#xA;changes the developer experience. I also still don&#39;t like the error handling&#xA;(but &lt;code&gt;must*&lt;/code&gt; goes far by improving the situation, when it is possible to use&#xA;it), especially because it is easy to lose context on it:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// bad&#xA;func readFileContents(file) ([]byte, error) {&#xA;    contents, err := os.ReadFile(file)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return contents, nil&#xA;}&#xA;&#xA;// good&#xA;func readFileContents(file) ([]byte, error) {&#xA;    contents, err := os.ReadFile(file)&#xA;    if err != nil {&#xA;        return nil, fmt.Errorf(&amp;quot;readFileContents: error while reading a file: %w&amp;quot;, err)&#xA;    }&#xA;    return contents, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I also have some grips about the mutate everything approach of the language. I&#xA;prefer immutability by default, but I find that in general as long as you split&#xA;your functions at a reasonable size it is generally fine.&lt;/p&gt;&#xA;&lt;p&gt;And for a language that is supposed to be straightforward, it is strange on how&#xA;much magic the language relies on, in the form of things like&#xA;&lt;a href=&#34;https://go.dev/doc/modules/layout&#34;&gt;&lt;code&gt;internal&lt;/code&gt;&lt;/a&gt; modules, conditional compiling&#xA;by filenames (e.g.: &lt;code&gt;foo_amd64.go&lt;/code&gt;, &lt;code&gt;bar_linux.go&lt;/code&gt;), magic comments (e.g.:&#xA;&lt;code&gt;//go:build&lt;/code&gt;), etc.&lt;/p&gt;&#xA;&lt;p&gt;I expect to write more Go code going forward. Not because it is the perfect&#xA;language or whatever, but just because it a is language that has some really&#xA;good qualities that makes the language attractive even with the issues that I&#xA;have. That makes it a reasonable good language, and at least for me this is&#xA;good enough.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-29/02-go-a-reasonable-good-language.md</guid>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Quick bits: why you should automate everything</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-29/01-quick-bits-why-you-should-automate-everything.md</link>
      <description>&lt;p&gt;If everything works as expected this blog post should appear in &lt;a href=&#34;https://kokada.capivaras.dev/&#34;&gt;in my&#xA;blog&lt;/a&gt; without I ever touching the&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; website. I rewrote my &lt;a href=&#34;https://kokada.capivaras.dev/blog/using-github-as-a-bad-blog-platform/&#34;&gt;previous Python&#xA;script&lt;/a&gt;&#xA;to Go&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/3c39e0f7cd58b1af885f69871490b05bf6fc7d99/blog.go&#34;&gt;permalink&lt;/a&gt;)&#xA;since my attempt to generate proper description to the RSS feed resulted in&#xA;slow startup times (not because of Python, but because of my usage of&#xA;&lt;code&gt;nix-shell&lt;/code&gt; since I didn&#39;t want to deal with&#xA;&lt;a href=&#34;https://docs.python.org/3/library/venv.html&#34;&gt;venv&lt;/a&gt; or anything to manage my&#xA;Python dependencies).&lt;/p&gt;&#xA;&lt;p&gt;My previous workflow of this blog already involved me writing the texts in&#xA;&lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt;, copying and pasting the result in the&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; website and publishing. This was not&#xA;that bad, except that it seems I have a heavy tendency of editing my posts&#xA;multiple times. Copying and pasting data between neovim and the website became&#xA;tedious, so I decided to give up and automate the whole process.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mataroa.blog/&#34;&gt;Mataroa&lt;/a&gt; (the blog platform&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; run) has a reasonable good&#xA;&lt;a href=&#34;https://mataroa.blog/api/docs/&#34;&gt;API&lt;/a&gt;, and it only took a few hours to get a&#xA;version of publishing working (it would take less if&#xA;&lt;a href=&#34;https://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt;, the framework Mataroa is written, did&#xA;not have a weird behavior with URLs missing a trailing &lt;code&gt;/&lt;/code&gt;). An additional few&#xA;lines of&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/51b20612335c7f4312a51a0f436235b4b701ce8b/.github/workflows/go.yml&#34;&gt;YAML&lt;/a&gt;&#xA;to make GitHub Actions trigger a pipeline and now I should never have to&#xA;manually update my blog again.&lt;/p&gt;&#xA;&lt;p&gt;I could have not done this. I mean, I probably wasted more time writing an&#xA;automation than I actually wasted publishing manually. But the manual process&#xA;is easy to miss, and I already did multiple mistakes publishing in the manual&#xA;method. For example, when writing the Markdown files, each post is written in a&#xA;particular format, where the first header is considered the title, so I need to&#xA;remove it from the contents during publication. But of course, this is easy to&#xA;miss, and I had to fix this multiple times already.&lt;/p&gt;&#xA;&lt;p&gt;So yes, I think this is a good lesson on why you should automate everything. It&#xA;is more than just about &lt;a href=&#34;https://xkcd.com/1205/&#34;&gt;time savings&lt;/a&gt;, it is about&#xA;reducing mistakes and even documenting (even if poorly) a process. I mean, the&#xA;code I wrote is not that great, but I can definitely rely on it in the future&#xA;to remember what I need to do. It will be much faster than trying to learn from&#xA;scratch again.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-29/01-quick-bits-why-you-should-automate-everything.md</guid>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Quick bits: nix-shell is cursed</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</link>
      <description>&lt;p&gt;The other day I had to run a PHP project in my machine. I have no idea how PHP&#xA;ecosystem work, I just wanted to get it to run.&lt;/p&gt;&#xA;&lt;p&gt;The easiest way to get a script to run if you use Nix is to use &lt;code&gt;nix-shell&lt;/code&gt;. As&#xA;many of you probably know, you can add &lt;code&gt;nix-shell&lt;/code&gt; as a shebang in your scripts&#xA;to run them as &lt;code&gt;./script&lt;/code&gt;. This was a PHP script so I wanted to do the same.&#xA;Easy right?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;#!nix-shell -i php -p php83&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Fatal error: strict_types declaration must be the very first statement in the script in index.php on line 4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So it seems that &lt;code&gt;declare(strict_types=1)&lt;/code&gt; needs to be the first line in a PHP&#xA;script if used. I removed &lt;code&gt;declare(strict_types=1)&lt;/code&gt; and while the script works,&#xA;I don&#39;t have enough expertise in PHP to know if this would be safe or not.&lt;/p&gt;&#xA;&lt;p&gt;I decided to try something that initially looked really dumb:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;#!nix-shell -i php -p php83&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Works&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Wat? I mean, it is not dumb if it works, but this at least looks cursed.&lt;/p&gt;&#xA;&lt;p&gt;Eventually I found this&#xA;&lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446220517&#34;&gt;comment&lt;/a&gt; in a&#xA;Nix issue talking about cases where &lt;code&gt;nix-shell&lt;/code&gt; shebang doesn&#39;t work. It looks&#xA;like the classic case of a &lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446222206&#34;&gt;bug that becomes a&#xA;feature&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Update: after posting this in&#xA;&lt;a href=&#34;https://lobste.rs/s/gkcgza/quick_bits_nix_shell_is_cursed&#34;&gt;Lobte.rs&lt;/a&gt;, it seems&#xA;someone decided to open a &lt;a href=&#34;https://github.com/NixOS/nix/pull/11202&#34;&gt;Pull&#xA;Request&lt;/a&gt; to document this behavior.&#xA;Also the equivalent for the new &lt;a href=&#34;https://nix.dev/manual/nix/2.23/command-ref/new-cli/nix#shebang-interpreter&#34;&gt;nix&#xA;CLI&lt;/a&gt;&#xA;explicitly documents this behavior:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Note that the &lt;code&gt;#! nix&lt;/code&gt; lines don&#39;t need to follow after the first line, to&#xA;accomodate other interpreters.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</guid>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Using GitHub as a (bad) blog platform</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</link>
      <description>&lt;p&gt;I finally started a new blog, thanks to the offer of&#xA;&lt;a href=&#34;https://gluer.org/&#34;&gt;@ratsclub&lt;/a&gt; to give me free access to&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;. But considering how small this blog&#xA;platform is supposed to be, I want to have at least somewhere to have a backup&#xA;of my posts. I know &lt;a href=&#34;https://mataroa.blog/&#34;&gt;Mataroa&lt;/a&gt;, the blog platform that&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt; runs, has automatic e-mail backups, but&#xA;I want something more reliable.&lt;/p&gt;&#xA;&lt;p&gt;I am writing all my posts in Markdown (the format that &lt;a href=&#34;https://1.mataroa.blog/guides/markdown/&#34;&gt;Mataroa&#xA;supports&lt;/a&gt;) files inside&#xA;&lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt; anyway, so why not store all my Markdown files in&#xA;Git? So this is what I did, I now have an unofficial mirror in&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;While I am here, why not overcomplicate? Can I make an usable blog platform&#xA;from GitHub? And by that I don&#39;t mean GitHub pages, the repository itself. I&#xA;mean, it already renders Markdown files by default, so no need to do anything&#xA;in that space. To reach feature parity with&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;, I only need to have an index and RSS&#xA;(since comments are not supported anyway). No need for newsletter since GitHub&#xA;has a &lt;a href=&#34;https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/managing-subscriptions-for-activity-on-github/viewing-your-subscriptions&#34;&gt;watch&#xA;feature&lt;/a&gt;&#xA;already.&lt;/p&gt;&#xA;&lt;p&gt;After a couple of hours hacking a Python script, you can see the result of this&#xA;monstrosity &lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;here&lt;/a&gt;. The script, called&#xA;&lt;code&gt;gen_blog.py&lt;/code&gt;, is available at the same repository (here is a&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/c8986d1ab1b94c0986fd814629bb8eb4034fb6e7/gen_blog.py&#34;&gt;permalink&lt;/a&gt;).&#xA;It automatically generates an index at&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/README.md&#34;&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; with&#xA;each blog post and a&#xA;&lt;a href=&#34;https://raw.githubusercontent.com/thiagokokada/blog/main/rss.xml&#34;&gt;&lt;code&gt;rss.xml&lt;/code&gt;&lt;/a&gt;&#xA;file at the root of the repository.&lt;/p&gt;&#xA;&lt;p&gt;Instead of trying to explain the code, I am going to explain the general idea,&#xA;because I think that if you want to replicate this idea it is better to rewrite&#xA;it in a way that you understand. It shouldn&#39;t take more than 2 hours in any&#xA;decent programming language. But if you really want, the script itself is&#xA;licensed in &lt;a href=&#34;https://en.wikipedia.org/wiki/WTFPL&#34;&gt;WTFPL&lt;/a&gt; license. The code only&#xA;uses Python 3&#39;s standard library and should work in any relatively recent&#xA;version (anything newer than 3.9 should work).&lt;/p&gt;&#xA;&lt;p&gt;So the idea is basically to organise the repository and the Markdown files in a&#xA;easy way that makes it trivial to parse in a deterministic way. For example, my&#xA;repository is organised in the following way:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root&#xA;├── 2024-07-26&#xA;│   ├── 01-writing-nixos-tests-for-fun-and-profit.md&#xA;│   └── 02-using-github-as-a-bad-blog-platform.md &amp;lt;- this file&#xA;├── gen_blog.py&#xA;├── README.md&#xA;└── rss.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Each day that you write a new blog post will be on its own directory. This is&#xA;nice because Markdown files may include extra files than the posts themselves,&#xA;e.g.: images, and this organisation make it trivial to organise everything.&lt;/p&gt;&#xA;&lt;p&gt;Each post has its own Markdown file. I put a two digit number before each post,&#xA;to ensure that when publishing multiple posts at the same day I keep them in&#xA;the same order of publishing. But if you don&#39;t care about it, you can just name&#xA;the files whatever you want.&lt;/p&gt;&#xA;&lt;p&gt;Also, I am assuming that each Markdown file has a header starting with &lt;code&gt;# &lt;/code&gt;,&#xA;and that is the title of the blog post.&lt;/p&gt;&#xA;&lt;p&gt;Using the above organisation, I have this function that scrapes the repository&#xA;and collect the necessary information to generate the index and RSS files:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def grab_posts(pwd: Path):&#xA;    posts = defaultdict(list)&#xA;&#xA;    for dir in sorted(pwd.iterdir(), reverse=True):&#xA;        # Ignore non-directories or hidden files&#xA;        if not dir.is_dir() or dir.name[0] == &amp;quot;.&amp;quot;:&#xA;            continue&#xA;&#xA;        # Try to parse date from directory name&#xA;        try:&#xA;            date = datetime.strptime(dir.name, &amp;quot;%Y-%m-%d&amp;quot;)&#xA;        except ValueError:&#xA;            print(f&amp;quot;WARN: ignoring non-date directory: {dir}&amp;quot;, file=sys.stderr)&#xA;            continue&#xA;&#xA;        # Iterate between the files in the date directory&#xA;        for post in sorted(dir.iterdir(), reverse=True):&#xA;            # Ignore non-markdown files or hidden files (draft)&#xA;            if not post.suffix == &amp;quot;.md&amp;quot; or post.name[0] == &amp;quot;.&amp;quot;:&#xA;                continue&#xA;&#xA;            # Grab the first H1 section to parse as title&#xA;            text = post.read_text()&#xA;            mTitle = re.match(r&amp;quot;# (?P&amp;lt;title&amp;gt;.*)\r?\n&amp;quot;, text)&#xA;            if mTitle and (title := mTitle.groupdict().get(&amp;quot;title&amp;quot;)):&#xA;                posts[date].append({&amp;quot;title&amp;quot;: title, &amp;quot;file&amp;quot;: str(post)})&#xA;            else:&#xA;                print(f&amp;quot;WARN: did not find title for file: {post}&amp;quot;, file=sys.stderr)&#xA;&#xA;    return posts&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Some interesting tidbits: if a Markdown file has a &lt;code&gt;.&lt;/code&gt; at the start I assume it&#xA;is a draft post, and ignore it from my scraper. I added a bunch of &lt;code&gt;WARN&lt;/code&gt;&#xA;prints to make sure that the me in the future doesn&#39;t do anything dumb. Also,&#xA;sorting in reverse since reverse chronological order is the one most people&#xA;expect in blogs (i.e.: more recent blog posts at top).&lt;/p&gt;&#xA;&lt;p&gt;After running the function above, I have a resulting dictionary that I can use&#xA;to generate either a &lt;code&gt;README.md&lt;/code&gt; file or Markdown:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen_readme(posts):&#xA;    titles = []&#xA;&#xA;    for date, dayPosts in posts.items():&#xA;        for post in dayPosts:&#xA;            # This creates a relative link to the Markdown file, .e.g.:&#xA;            # ./02-using-github-as-a-bad-blog-platform.md&#xA;            link = os.path.join(&amp;quot;.&amp;quot;, post[&amp;quot;file&amp;quot;])&#xA;            # This formats the title, e.g.:&#xA;            # - [Using GitHub as a (bad) blog platform](./2024-07-26/02-using-github-as-a-bad-blog-platform.md) - 2024-07-26&#xA;            title = date.strftime(f&amp;quot;- [{post[&#39;title&#39;]}]({link}) - %Y-%m-%d&amp;quot;)&#xA;            # This appends to the list to generate the content later&#xA;            titles.append(title)&#xA;&#xA;    # README_TEMPLATE is a string with the static part of the README&#xA;    print(README_TEMPLATE.format(posts=&amp;quot;\n&amp;quot;.join(titles)))&#xA;&#xA;&#xA;def gen_rss(posts):&#xA;    # Got most of the specification from here:&#xA;    # https://www.w3schools.com/XML/xml_rss.asp&#xA;    rss = ET.Element(&amp;quot;rss&amp;quot;, version=&amp;quot;2.0&amp;quot;)&#xA;&#xA;    # Here are the RSS metadata for the blog itself&#xA;    channel = ET.SubElement(rss, &amp;quot;channel&amp;quot;)&#xA;    ET.SubElement(channel, &amp;quot;title&amp;quot;).text = &amp;quot;kokada&#39;s blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;link&amp;quot;).text = &amp;quot;https://github.com/thiagokokada/blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;description&amp;quot;).text = &amp;quot;dd if=/dev/urandom of=/dev/brain0&amp;quot;&#xA;&#xA;    # You create one item for each blog post&#xA;    for date, dayPost in posts.items():&#xA;        for post in dayPost:&#xA;            item = ET.SubElement(channel, &amp;quot;item&amp;quot;)&#xA;            link = urljoin(RSS_POST_LINK_PREFIX, post[&amp;quot;file&amp;quot;])&#xA;            ET.SubElement(item, &amp;quot;title&amp;quot;).text = post[&amp;quot;title&amp;quot;]&#xA;            ET.SubElement(item, &amp;quot;guid&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;link&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;pubDate&amp;quot;).text = date.strftime(&#39;%a, %d %b %Y %H:%M:%S GMT&#39;)&#xA;&#xA;    # Generate the XML and indent&#xA;    tree = ET.ElementTree(rss)&#xA;    ET.indent(tree, space=&amp;quot;\t&amp;quot;, level=0)&#xA;    tree.write(&amp;quot;rss.xml&amp;quot;, xml_declaration=True, encoding=&amp;quot;UTF-8&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To publish a new Post, a basically write a Markdown file, run `./gen_readme.py&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;README.md` at the root of the repository, and see the magic happen.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;It works much better than I initially anticipated. The &lt;code&gt;README.md&lt;/code&gt; is properly&#xA;populated with the titles and links. The RSS is kind of empty since it has no&#xA;description, but it seems to work fine (at least in&#xA;&lt;a href=&#34;https://www.inoreader.com/&#34;&gt;Inoreader&lt;/a&gt;, my RSS reader of choice). I can&#xA;probably fill the post description with more information if I really want, but&#xA;it is enough for now (update: it is working now, you just need to render the&#xA;Markdown as HTML and escape the tags;&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/9506051cc3d49f203304174b335ff62de9d17a05/gen_blog.py&#34;&gt;permalink&lt;/a&gt;&#xA;for the updated script). Not sure who is that interested in my writing that&#xA;will want to use this RSS feed instead the one available in&#xA;&lt;a href=&#34;https://kokada.capivaras.dev/rss/&#34;&gt;capivaras.dev&lt;/a&gt; anyway.&lt;/p&gt;&#xA;&lt;p&gt;Also, while I am using GitHub here, the same idea would work in GitLab, Gitea,&#xA;sr.ht or whatever. As long as your source hub supports Markdown files it should&#xA;work.&lt;/p&gt;&#xA;&lt;p&gt;So that is it. I am not saying this is a good idea for your primary blog&#xA;platform or whatever, and I still prefer to publish to a platform that doesn&#39;t&#xA;track users or have tons of JavaScript or whatever. But if you want a backup of&#xA;your posts and you are already writing Markdown anyway, well, there are worse&#xA;ways to do it I think.&lt;/p&gt;&#xA;&lt;p&gt;Update: I rewrote the script again using Go&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/3ece3853e7dd32977e7ec5238d2955e530ca4beb/blog.go&#34;&gt;permalink&lt;/a&gt;).&#xA;The reason for it is because when I started rendering Markdown (for&#xA;descriptions) the Python version got quite slow (not the fault of Python&#xA;itself, mostly because of the usage of &lt;code&gt;nix-shell&lt;/code&gt; to manage dependencies;&#xA;something that Go doesn&#39;t need). Took about half an hour, showing how easy it&#xA;is to do the same.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Writing NixOS tests for fun and profit</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</link>
      <description>&lt;p&gt;I recently started a &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go&#34;&gt;new side&#xA;project&lt;/a&gt; writing an IPC library in&#xA;Go for &lt;a href=&#34;https://hyprland.org/&#34;&gt;Hyprland&lt;/a&gt;, a Window Manager for Wayland.&lt;/p&gt;&#xA;&lt;p&gt;Once I got past the Work-in-Progress phase, I realise I had an issue: I wrote&#xA;some tests, but I was running then inside my system running Hyprland. And the&#xA;tests themselves were annoying: since they send commands to the current running&#xA;Hyprland instance, I was having programs being opened and settings being&#xA;changed, because this was the only way to have a reasonable good confidence&#xA;that what I was doing was correct. So I need to do like any good developer and&#xA;implement a CI, but how?&lt;/p&gt;&#xA;&lt;p&gt;One approach would be to create something like a mock client and test against&#xA;my mock. Since this mock wouldn&#39;t need a running Hyprland instance the tests&#xA;could run everywhere (even in non-Linux systems!), but they wouldn&#39;t be much&#xA;useful. Mocks are great for testing business logic, but not really for making&#xA;sure everything is working correctly.&lt;/p&gt;&#xA;&lt;p&gt;I need something more akin to an integration test, but this is tricky. It is&#xA;not like I am doing integration with e.g.: PostgreSQL that has thousands of&#xA;libraries available to make integration tests easier, I am doing integration&#xA;with a Window Manager that is a moving target with multiple breaking changes in&#xA;each release. And this is where NixOS tests enter, a way to run tests inside&#xA;Virtual Machines configured in Nix.&lt;/p&gt;&#xA;&lt;p&gt;I am a long time NixOS user and commiter, but I never wrote a NixOS test&#xA;outside of &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;nixpkgs&lt;/a&gt; itself. However I knew&#xA;it was possible, and after doing a quick reading of the &lt;a href=&#34;https://wiki.nixos.org/wiki/NixOS_VM_tests&#34;&gt;Wiki&#xA;entry&lt;/a&gt; about it, I was ready to&#xA;start.&lt;/p&gt;&#xA;&lt;p&gt;The first part is to call &lt;code&gt;pkgs.testers.runNixOSTest&lt;/code&gt; and configure the machine&#xA;as any other NixOS system, e.g.:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ pkgs, ... }:&#xA;pkgs.testers.runNixOSTest {&#xA;  name = &amp;quot;hyprland-go&amp;quot;;&#xA;&#xA;  nodes.machine =&#xA;    { config, pkgs, lib, ... }:&#xA;    {&#xA;      # bootloader related configuration&#xA;      boot.loader.systemd-boot.enable = true;&#xA;      boot.loader.efi.canTouchEfiVariables = true;&#xA;&#xA;      # enable hyprland&#xA;      programs.hyprland.enable = true;&#xA;&#xA;      # create a user called alice&#xA;      users.users.alice = {&#xA;        isNormalUser = true;&#xA;      };&#xA;&#xA;      # add some extra packages that we need during tests&#xA;      environment.systemPackages = with pkgs; [ go kitty ];&#xA;&#xA;      # auto login as alice&#xA;      services.getty.autologinUser = &amp;quot;alice&amp;quot;;&#xA;&#xA;      # configure VM, increase memory and CPU and enable OpenGL via LLVMPipe&#xA;      virtualisation.qemu = {&#xA;        options = [&#xA;          &amp;quot;-smp 2&amp;quot;&#xA;          &amp;quot;-m 4G&amp;quot;&#xA;          &amp;quot;-vga none&amp;quot;&#xA;          &amp;quot;-device virtio-gpu-pci&amp;quot;&#xA;        ];&#xA;      };&#xA;&#xA;      # Start hyprland at login&#xA;      programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;;&#xA;    };&#xA;&#xA;  testScript = &amp;quot;start_all()&amp;quot;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A few details that I want to bring to attention. The first one is how easy it&#xA;is to setup things like a normal user account, add some extra packages we need&#xA;for testing, add Hyprland itself and configure auto-login. I have no idea how&#xA;painful it would be to automatise all those steps in e.g.: Ansible, but here we&#xA;are in a few lines of Nix code. This is, of course, thanks to all the&#xA;contributors to nixpkgs that implement something that help their own use case,&#xA;but once combined make it greater than the sum of the parts.&lt;/p&gt;&#xA;&lt;p&gt;Second is something that I took a while to figure out: how to enable GPU&#xA;acceleration inside the VM. You see, Hyprland, different from other Window&#xA;Managers, requires OpenGL support. This is basically why the flag &lt;code&gt;-device virtio-gpu-pci&lt;/code&gt; is in &lt;code&gt;virtualisation.qemu.options&lt;/code&gt;, this enables OpenGL&#xA;rendering via LLVMPipe, that while being slow since it is rendered in CPU, is&#xA;sufficient for this case.&lt;/p&gt;&#xA;&lt;p&gt;Putting the above code inside a&#xA;&lt;a href=&#34;https://wiki.nixos.org/wiki/Flakes&#34;&gt;&lt;code&gt;flake.nix&lt;/code&gt;&lt;/a&gt; for reproducibility, I had&#xA;something similar to:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  description = &amp;quot;Hyprland&#39;s IPC bindings for Go&amp;quot;;&#xA;&#xA;  inputs = {&#xA;    nixpkgs.url = &amp;quot;github:NixOS/nixpkgs/nixos-unstable&amp;quot;;&#xA;  };&#xA;&#xA;  outputs = { nixpkgs, ... }:&#xA;    {&#xA;      checks.x86_64-linux =&#xA;        let&#xA;          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };&#xA;        in&#xA;        {&#xA;          testVm = pkgs.testers.runNixOSTest {&#xA;            # the code above&#xA;          };&#xA;        }&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I can now run &lt;code&gt;nix build .#checks.x86_64-linux.testVm -L&lt;/code&gt; to build and run the&#xA;VM. However it is not really useful right now, since we didn&#39;t add any useful&#xA;code in &lt;code&gt;testScript&lt;/code&gt;, the core of the NixOS test framework. We can also run&#xA;&lt;code&gt;nix build .#checks.x86_64-linux.testVm.driverInteractive&lt;/code&gt; and&#xA;&lt;code&gt;./result/bin/nixos-test-driver&lt;/code&gt;: this will start a Python console where we can&#xA;manually play with the VM (try typing &lt;code&gt;start_all()&lt;/code&gt; for example).&lt;/p&gt;&#xA;&lt;p&gt;The &lt;code&gt;testScript&lt;/code&gt; is a sequence of Python statements that perform various&#xA;actions, such as starting VMs, executing commands in the VMs, and so on. More&#xA;about it in the official&#xA;&lt;a href=&#34;https://nixos.org/manual/nixos/stable/index.html#sec-nixos-tests&#34;&gt;documentation&lt;/a&gt;.&#xA;For our case we can start with something like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;    testScript = /* python */ &#39;&#39;&#xA;      start_all()&#xA;&#xA;      machine.wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&#xA;      machine.wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The first statement, &lt;code&gt;start_all()&lt;/code&gt;, starts all VMs, in this case we have only&#xA;one, called &lt;code&gt;machine&lt;/code&gt;. We send two further commands to &lt;code&gt;machine&lt;/code&gt;:&#xA;&lt;code&gt;wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&lt;/code&gt; and&#xA;&lt;code&gt;wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The first command waits until systemd&#39;s &lt;code&gt;multi-user.target&lt;/code&gt; is ready, a good&#xA;way to ensure that the system is ready for further commands. The second one we&#xA;wait for a file called &lt;code&gt;test-finished&lt;/code&gt; to appear in Alice&#39;s &lt;code&gt;$HOME&lt;/code&gt; (basically,&#xA;a canary), but how can we generate this file?&lt;/p&gt;&#xA;&lt;p&gt;Remember that we added &lt;code&gt;programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;&lt;/code&gt;, that&#xA;automatically starts Hyprland when Alice logs in. We need to modify that&#xA;command to run the Go tests from our library. The good thing is that Hyprland&#xA;configuration file supports a&#xA;&lt;a href=&#34;https://wiki.hyprland.org/Configuring/Keywords/#executing&#34;&gt;&lt;code&gt;exec-once&lt;/code&gt;&lt;/a&gt;&#xA;command that runs a command during Hyprland launch. We can abuse this to launch&#xA;a terminal emulator and run our tests:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  programs.bash.loginShellInit =&#xA;    let&#xA;      testScript = pkgs.writeShellScript &amp;quot;hyprland-go-test&amp;quot; &#39;&#39;&#xA;        set -euo pipefail&#xA;&#xA;        trap &#39;echo $? &amp;gt; $HOME/test-finished&#39; EXIT # creates the canary when the script finishes&#xA;&#xA;        cd ${./.} # go to the library directory&#xA;        go test -v ./... &amp;gt; $HOME/test.log 2&amp;gt;&amp;amp;1 # run Go tests&#xA;      &#39;&#39;;&#xA;      hyprlandConf = pkgs.writeText &amp;quot;hyprland.conf&amp;quot; &#39;&#39;&#xA;        exec-once = kitty sh -c ${testScript}&#xA;      &#39;&#39;;&#xA;    in &#39;&#39;&#xA;      Hyprland --config ${hyprlandConf}&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So we are basically creating a custom Hyprland config that starts a&#xA;&lt;a href=&#34;https://sw.kovidgoyal.net/kitty/&#34;&gt;Kitty&lt;/a&gt; terminal emulator, that then launches&#xA;a shell script that runs the test. Since we have no way to get the results of&#xA;the test, we pipe the output to a file that we can collect later (e.g.:&#xA;&lt;code&gt;machine.succeded(&amp;quot;cat /home/alice/test.log&amp;quot;)&lt;/code&gt;). And once the script exit, we&#xA;create the canary file &lt;code&gt;$HOME/test-finished&lt;/code&gt;, that allows the &lt;code&gt;testScript&lt;/code&gt;&#xA;knows that the test finished and it can destroy the VM safely.&lt;/p&gt;&#xA;&lt;p&gt;If you want to take a look at the final result, it is&#xA;&lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/blob/v0.0.1/flake.nix&#34;&gt;here&lt;/a&gt;. This&#xA;tests run in any Linux machine that supports KVM, and also works in &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/actions/workflows/nix.yaml&#34;&gt;GitHub&#xA;Actions&lt;/a&gt;&#xA;thanks to the the&#xA;&lt;a href=&#34;https://github.com/DeterminateSystems/nix-installer-action&#34;&gt;nix-installer-action&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;And now I have a proper CI pipeline in a way that I never imagined would be&#xA;possible, especially considering how simple it was.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>