<?xml version='1.0' encoding='UTF-8'?>
<rss version="2.0">
	<channel>
		<title>kokada's blog</title>
		<link>https://github.com/thiagokokada/blog</link>
		<description>dd if=/dev/urandom of=/dev/brain0</description>
		<item>
			<title>Quick bits: nix-shell is cursed</title>
			<guid>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</guid>
			<description>&lt;h1&gt;Quick bits: nix-shell is cursed&lt;/h1&gt;
&lt;p&gt;The other day I had to run a PHP project in my machine. I have no idea how PHP
ecosystem work, I just wanted to get it to run.&lt;/p&gt;
&lt;p&gt;The easiest way to get a script to run if you use Nix is to use &lt;code&gt;nix-shell&lt;/code&gt;. As
many of you probably know, you can add &lt;code&gt;nix-shell&lt;/code&gt; as a shebang in your scripts
to run them as &lt;code&gt;./script&lt;/code&gt;. This was a PHP script so I wanted to do the same.
Easy right?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;#!/use/bin/env nix-shell
#!nix-shell -i php -p php83
&amp;lt;?php
declare(strict_types=1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-console"&gt;$ ./index.php
Fatal error: strict_types declaration must be the very first statement in the script in index.php on line 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it seems that &lt;code&gt;declare(strict_types=1)&lt;/code&gt; needs to be the first line in a PHP
script if used. I removed &lt;code&gt;declare(strict_types=1)&lt;/code&gt; and while the script works,
I don't have enough expertise in PHP to know if this would be safe or not.&lt;/p&gt;
&lt;p&gt;I decided to try something that initially looked really dumb:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;#!/use/bin/env nix-shell
&amp;lt;?php
declare(strict_types=1);
#!nix-shell -i php -p php83
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-console"&gt;$ ./index.php
Works
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wat? I mean, it is not dumb if it works, but this at least looks cursed.&lt;/p&gt;
&lt;p&gt;Eventually I found this
&lt;a href="https://github.com/NixOS/nix/issues/2570#issuecomment-446220517"&gt;comment&lt;/a&gt; in a
Nix issue talking about cases where &lt;code&gt;nix-shell&lt;/code&gt; shebang doesn't work. It looks
like the classic case of a &lt;a href="https://github.com/NixOS/nix/issues/2570#issuecomment-446222206"&gt;bug that becomes a
feature&lt;/a&gt;.&lt;/p&gt;
</description>
			<link>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</link>
			<pubDate>Sat, 27 Jul 2024 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>Using GitHub as a (bad) blog platform</title>
			<guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</guid>
			<description>&lt;h1&gt;Using GitHub as a (bad) blog platform&lt;/h1&gt;
&lt;p&gt;I finally started a new blog, thanks to the offer of
&lt;a href="https://gluer.org/"&gt;@ratsclub&lt;/a&gt; to give me free access to
&lt;a href="https://capivaras.dev/"&gt;capivaras.dev&lt;/a&gt;. But considering how small this blog
platform is supposed to be, I want to have at least somewhere to have a backup
of my posts. I know &lt;a href="https://mataroa.blog/"&gt;Mataroa&lt;/a&gt;, the blog platform that
&lt;a href="https://capivaras.dev/"&gt;capivaras.dev&lt;/a&gt; runs, has automatic e-mail backups, but
I want something more reliable.&lt;/p&gt;
&lt;p&gt;I am writing all my posts in Markdown (the format that &lt;a href="https://1.mataroa.blog/guides/markdown/"&gt;Mataroa
supports&lt;/a&gt;) files inside
&lt;a href="https://neovim.io/"&gt;neovim&lt;/a&gt; anyway, so why not store all my Markdown files in
Git? So this is what I did, I now have an unofficial mirror in
&lt;a href="https://github.com/thiagokokada/blog"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While I am here, why not to overcomplicate? Can I make an usable blog platform
from GitHub? And by that I don't mean GitHub pages, the repository itself. I
mean, it already renders Markdown files by default, so no need to do anything
in that space. To reach feature parity with
&lt;a href="https://capivaras.dev/"&gt;capivaras.dev&lt;/a&gt;, I only need to have an index and RSS
(since comments are not supported anyway). No need for newsletter since GitHub
has a &lt;a href="https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/managing-subscriptions-for-activity-on-github/viewing-your-subscriptions"&gt;watch
feature&lt;/a&gt;
already.&lt;/p&gt;
&lt;p&gt;After a couple of hours hacking a Python script, you can see the result of this
monstrosity &lt;a href="https://github.com/thiagokokada/blog"&gt;here&lt;/a&gt;. The script, called
&lt;code&gt;gen_blog.py&lt;/code&gt;, is available at the same repository (here is a
&lt;a href="https://github.com/thiagokokada/blog/blob/c8986d1ab1b94c0986fd814629bb8eb4034fb6e7/gen_blog.py"&gt;permalink&lt;/a&gt;).
It automatically generates an index at
&lt;a href="https://github.com/thiagokokada/blog/blob/main/README.md"&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; with
each blog post and a
&lt;a href="https://raw.githubusercontent.com/thiagokokada/blog/main/rss.xml"&gt;&lt;code&gt;rss.xml&lt;/code&gt;&lt;/a&gt;
file at the root of the repository.&lt;/p&gt;
&lt;p&gt;Instead of trying to explain the code, I am going to explain the general idea,
because I think that if you want to replicate this idea it is better to rewrite
it in a way that you understand. It shouldn't take more than 2 hours in any
decent programming language. But if you really want, the script itself is
licensed in &lt;a href="https://en.wikipedia.org/wiki/WTFPL"&gt;WTFPL&lt;/a&gt; license. The code only
uses Python 3's standard library and should work in any relatively recent
version (anything newer than 3.9 should work).&lt;/p&gt;
&lt;p&gt;So the idea is basically to organise the repository and the Markdown files in a
easy way that makes it trivial to parse in a deterministic way. For example, my
repository is organised in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root
├── 2024-07-26
│   ├── 01-writing-nixos-tests-for-fun-and-profit.md
│   └── 02-using-github-as-a-bad-blog-platform.md &amp;lt;- this file
├── gen_blog.py
├── README.md
└── rss.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each day that you write a new blog post will be on its own directory. This is
nice because Markdown files may include extra files than the posts themselves,
e.g.: images, and this organisation make it trivial to organise everything.&lt;/p&gt;
&lt;p&gt;Each post has its own Markdown file. I put a two digit number before each post,
to ensure that when publishing multiple posts at the same day I keep them in
the same order of publishing. But if you don't care about it, you can just name
the files whatever you want.&lt;/p&gt;
&lt;p&gt;Also, I am assuming that each Markdown file has a header starting with &lt;code&gt;# &lt;/code&gt;,
and that is the title of the blog post.&lt;/p&gt;
&lt;p&gt;Using the above organisation, I have this function that scrap the repository
and collect the necessary information to generate the index and RSS files:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def grab_posts(pwd: Path):
    posts = defaultdict(list)

    for dir in sorted(pwd.iterdir(), reverse=True):
        # Ignore non-directories or hidden files
        if not dir.is_dir() or dir.name[0] == &amp;quot;.&amp;quot;:
            continue

        # Try to parse date from directory name
        try:
            date = datetime.strptime(dir.name, &amp;quot;%Y-%m-%d&amp;quot;)
        except ValueError:
            print(f&amp;quot;WARN: ignoring non-date directory: {dir}&amp;quot;, file=sys.stderr)
            continue

        # Iterate between the files in the date directory
        for post in sorted(dir.iterdir(), reverse=True):
            # Ignore non-markdown files or hidden files (draft)
            if not post.suffix == &amp;quot;.md&amp;quot; or post.name[0] == &amp;quot;.&amp;quot;:
                continue

            # Grab the first H1 section to parse as title
            text = post.read_text()
            mTitle = re.match(r&amp;quot;# (?P&amp;lt;title&amp;gt;.*)\r?\n&amp;quot;, text)
            if mTitle and (title := mTitle.groupdict().get(&amp;quot;title&amp;quot;)):
                posts[date].append({&amp;quot;title&amp;quot;: title, &amp;quot;file&amp;quot;: str(post)})
            else:
                print(f&amp;quot;WARN: did not find title for file: {post}&amp;quot;, file=sys.stderr)

    return posts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some interesting tidbits: if a Markdown file has a &lt;code&gt;.&lt;/code&gt; at the start I assume it
is a draft post, and ignore it from my scrapper. I added a bunch of &lt;code&gt;WARN&lt;/code&gt;
prints to make sure that the me in the future doesn't do anything dumb. Also,
sorting in reverse since reverse chronological order is the one most people
expect in blogs (i.e.: more recent blog posts at top).&lt;/p&gt;
&lt;p&gt;After running the function above, I have a resulting dictionary that I can use
to generate either a &lt;code&gt;README.md&lt;/code&gt; file or Markdown:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def gen_readme(posts):
    titles = []

    for date, dayPosts in posts.items():
        for post in dayPosts:
            # This creates a relative link to the Markdown file, .e.g.:
            # ./02-using-github-as-a-bad-blog-platform.md
            link = os.path.join(&amp;quot;.&amp;quot;, post[&amp;quot;file&amp;quot;])
            # This formats the title, e.g.:
            # - [Using GitHub as a (bad) blog platform](./2024-07-26/02-using-github-as-a-bad-blog-platform.md) - 2024-07-26
            title = date.strftime(f&amp;quot;- [{post['title']}]({link}) - %Y-%m-%d&amp;quot;)
            # This appends to the list to generate the content later
            titles.append(title)

    # README_TEMPLATE is a string with the static part of the README
    print(README_TEMPLATE.format(posts=&amp;quot;\n&amp;quot;.join(titles)))


def gen_rss(posts):
    # Got most of the specification from here:
    # https://www.w3schools.com/XML/xml_rss.asp
    rss = ET.Element(&amp;quot;rss&amp;quot;, version=&amp;quot;2.0&amp;quot;)

    # Here are the RSS metadata for the blog itself
    channel = ET.SubElement(rss, &amp;quot;channel&amp;quot;)
    ET.SubElement(channel, &amp;quot;title&amp;quot;).text = &amp;quot;kokada's blog&amp;quot;
    ET.SubElement(channel, &amp;quot;link&amp;quot;).text = &amp;quot;https://github.com/thiagokokada/blog&amp;quot;
    ET.SubElement(channel, &amp;quot;description&amp;quot;).text = &amp;quot;dd if=/dev/urandom of=/dev/brain0&amp;quot;

    # You create one item for each blog post
    for date, dayPost in posts.items():
        for post in dayPost:
            item = ET.SubElement(channel, &amp;quot;item&amp;quot;)
            link = urljoin(RSS_POST_LINK_PREFIX, post[&amp;quot;file&amp;quot;])
            ET.SubElement(item, &amp;quot;title&amp;quot;).text = post[&amp;quot;title&amp;quot;]
            ET.SubElement(item, &amp;quot;guid&amp;quot;).text = link
            ET.SubElement(item, &amp;quot;link&amp;quot;).text = link
            ET.SubElement(item, &amp;quot;pubDate&amp;quot;).text = date.strftime('%a, %d %b %Y %H:%M:%S GMT')

    # Generate the XML and indent
    tree = ET.ElementTree(rss)
    ET.indent(tree, space=&amp;quot;\t&amp;quot;, level=0)
    tree.write(&amp;quot;rss.xml&amp;quot;, xml_declaration=True, encoding=&amp;quot;UTF-8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To publish a new Post, a basically write a Markdown file, run
&lt;code&gt;./gen_readme.py &amp;gt; README.md&lt;/code&gt; at the root of the repository, and see the magic
happens.&lt;/p&gt;
&lt;p&gt;It works much better than I initially antecipated. The &lt;code&gt;README.md&lt;/code&gt; is properly
populated with the titles and links. The RSS is kind empty since it has no
description, but it seems to work fine (at least in
&lt;a href="https://www.inoreader.com/"&gt;Inoreader&lt;/a&gt;, my RSS reader of choice). I can
probably fill the post description with more information if I really want, but
it is enough for now (update: it is working now, you just need to render the
Markdown as HTML and escape the tags;
&lt;a href="https://github.com/thiagokokada/blog/blob/9506051cc3d49f203304174b335ff62de9d17a05/gen_blog.py"&gt;permalink&lt;/a&gt;
for the updated script). Not sure who is that interested in my writing that
will want to use this RSS feed instead the one available in
&lt;a href="https://kokada.capivaras.dev/rss/"&gt;capivaras.dev&lt;/a&gt; anyway.&lt;/p&gt;
&lt;p&gt;Also, while I am using GitHub here, the same idea would work in GitLab, Gitea,
sr.ht or whatever. As long as your source hub supports Markdown files it should
work.&lt;/p&gt;
&lt;p&gt;So that is it. I am not saying this is a good idea for your primary blog
platform or whatever, and I still prefer to publish to a platform that doesn't
track users or have tons of JavaScript or whatever. But if you want a backup of
your posts and you are already writing Markdown anyway, well, there are worse
ways to do it I think.&lt;/p&gt;
</description>
			<link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</link>
			<pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>Writing NixOS tests for fun and profit</title>
			<guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</guid>
			<description>&lt;h1&gt;Writing NixOS tests for fun and profit&lt;/h1&gt;
&lt;p&gt;I recently started a &lt;a href="https://github.com/thiagokokada/hyprland-go"&gt;new side
project&lt;/a&gt; writing an IPC library in
Go for &lt;a href="https://hyprland.org/"&gt;Hyprland&lt;/a&gt;, a Window Manager for Wayland.&lt;/p&gt;
&lt;p&gt;Once I got past the Work-in-Progress phase, I realise I had an issue: I wrote
some tests, but I was running then inside my system running Hyprland. And the
tests themselves were annoying: since they send commands to the current running
Hyprland instance, I was having programs being opened and settings being
changed, because this was the only way to have a reasonable good confidence
that what I was doing was correct. So I need to do like any good developer and
implement a CI, but how?&lt;/p&gt;
&lt;p&gt;One approach would be to create something like a mock client and test against
my mock. Since this mock wouldn't need a running Hyprland instance the tests
could run everywhere (even in non-Linux systems!), but they wouldn't be much
useful. Mocks are great for testing business logic, but not really for making
sure everything is working correctly.&lt;/p&gt;
&lt;p&gt;I need something more akin to an integration test, but this is tricky. It is
not like I am doing integration with e.g.: PostgreSQL that has thousands of
libraries available to make integration tests easier, I am doing integration
with a Window Manager that is a moving target with multiple breaking changes in
each release. And this is where NixOS tests enter, a way to run tests inside
Virtual Machines configured in Nix.&lt;/p&gt;
&lt;p&gt;I am a long time NixOS user and commiter, but I never wrote a NixOS test
outside of &lt;a href="https://github.com/NixOS/nixpkgs"&gt;nixpkgs&lt;/a&gt; itself. However I knew
it was possible, and after doing a quick reading of the &lt;a href="https://wiki.nixos.org/wiki/NixOS_VM_tests"&gt;Wiki
entry&lt;/a&gt; about it, I was ready to
start.&lt;/p&gt;
&lt;p&gt;The first part is to call &lt;code&gt;pkgs.testers.runNixOSTest&lt;/code&gt; and configure the machine
as any other NixOS system, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-nix"&gt;{ pkgs, ... }:
pkgs.testers.runNixOSTest {
  name = &amp;quot;hyprland-go&amp;quot;;

  nodes.machine =
    { config, pkgs, lib, ... }:
    {
      # bootloader related configuration
      boot.loader.systemd-boot.enable = true;
      boot.loader.efi.canTouchEfiVariables = true;

      # enable hyprland
      programs.hyprland.enable = true;

      # create a user called alice
      users.users.alice = {
        isNormalUser = true;
      };

      # add some extra packages that we need during tests
      environment.systemPackages = with pkgs; [ go kitty ];

      # auto login as alice
      services.getty.autologinUser = &amp;quot;alice&amp;quot;;

      # configure VM, increase memory and CPU and enable OpenGL via LLVMPipe
      virtualisation.qemu = {
        options = [
          &amp;quot;-smp 2&amp;quot;
          &amp;quot;-m 4G&amp;quot;
          &amp;quot;-vga none&amp;quot;
          &amp;quot;-device virtio-gpu-pci&amp;quot;
        ];
      };

      # Start hyprland at login
      programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;;
    };

  testScript = &amp;quot;start_all()&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A few details that I want to bring to attention. The first one is how easy it
is to setup things like a normal user account, add some extra packages we need
for testing, add Hyprland itself and configure auto-login. I have no idea how
painful it would be to automatise all those steps in e.g.: Ansible, but here we
are in a few lines of Nix code. This is, of course, thanks to all the
contributors to nixpkgs that implement something that help their own use case,
but once combined make it greater than the sum of the parts.&lt;/p&gt;
&lt;p&gt;Second is something that I took a while to figure out: how to enable GPU
acceleration inside the VM. You see, Hyprland, different from other Window
Managers, requires OpenGL support. This is basically why the flag &lt;code&gt;-device virtio-gpu-pci&lt;/code&gt; is in &lt;code&gt;virtualisation.qemu.options&lt;/code&gt;, this enables OpenGL
rendering via LLVMPipe, that while being slow since it is rendered in CPU, is
sufficient for this case.&lt;/p&gt;
&lt;p&gt;Putting the above code inside a
&lt;a href="https://wiki.nixos.org/wiki/Flakes"&gt;&lt;code&gt;flake.nix&lt;/code&gt;&lt;/a&gt; for reproducibility, I had
something similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-nix"&gt;{
  description = &amp;quot;Hyprland's IPC bindings for Go&amp;quot;;

  inputs = {
    nixpkgs.url = &amp;quot;github:NixOS/nixpkgs/nixos-unstable&amp;quot;;
  };

  outputs = { nixpkgs, ... }:
    {
      checks.x86_64-linux =
        let
          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };
        in
        {
          testVm = pkgs.testers.runNixOSTest {
            # the code above
          };
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can now run &lt;code&gt;nix build .#checks.x86_64-linux.testVm -L&lt;/code&gt; to build and run the
VM. However it is not really useful right now, since we didn't add any useful
code in &lt;code&gt;testScript&lt;/code&gt;, the core of the NixOS test framework. We can also run
&lt;code&gt;nix build .#checks.x86_64-linux.testVm.driverInteractive&lt;/code&gt; and
&lt;code&gt;./result/bin/nixos-test-driver&lt;/code&gt;: this will start a Python console where we can
manually play with the VM (try typing &lt;code&gt;start_all()&lt;/code&gt; for example).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;testScript&lt;/code&gt; is a sequence of Python statements that perform various
actions, such as starting VMs, executing commands in the VMs, and so on. More
about it in the official
&lt;a href="https://nixos.org/manual/nixos/stable/index.html#sec-nixos-tests"&gt;documentation&lt;/a&gt;.
For our case we can start with something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-nix"&gt;{
    testScript = /* python */ ''
      start_all()

      machine.wait_for_unit(&amp;quot;multi-user.target&amp;quot;)
      machine.wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)
    '';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first statement, &lt;code&gt;start_all()&lt;/code&gt;, starts all VMs, in this case we have only
one, called &lt;code&gt;machine&lt;/code&gt;. We send two further commands to &lt;code&gt;machine&lt;/code&gt;:
&lt;code&gt;wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&lt;/code&gt; and
&lt;code&gt;wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first command waits until systemd's &lt;code&gt;multi-user.target&lt;/code&gt; is ready, a good
way to ensure that the system is ready for further commands. The second one we
wait for a file called &lt;code&gt;test-finished&lt;/code&gt; to appear in Alice's &lt;code&gt;$HOME&lt;/code&gt; (basically,
a canary), but how can we generate this file?&lt;/p&gt;
&lt;p&gt;Remember that we added &lt;code&gt;programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;&lt;/code&gt;, that
automatically starts Hyprland when Alice logs in. We need to modify that
command to run the Go tests from our library. The good thing is that Hyprland
configuration file supports a
&lt;a href="https://wiki.hyprland.org/Configuring/Keywords/#executing"&gt;&lt;code&gt;exec-once&lt;/code&gt;&lt;/a&gt;
command that runs a command during Hyprland launch. We can abuse this to launch
a terminal emulator and run our tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-nix"&gt;{
  programs.bash.loginShellInit =
    let
      testScript = pkgs.writeShellScript &amp;quot;hyprland-go-test&amp;quot; ''
        set -euo pipefail

        trap 'echo $? &amp;gt; $HOME/test-finished' EXIT # creates the canary when the script finishes

        cd ${./.} # go to the library directory
        go test -v ./... &amp;gt; $HOME/test.log 2&amp;gt;&amp;amp;1 # run Go tests
      '';
      hyprlandConf = pkgs.writeText &amp;quot;hyprland.conf&amp;quot; ''
        exec-once = kitty sh -c ${testScript}
      '';
    in ''
      Hyprland --config ${hyprlandConf}
    '';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we are basically creating a custom Hyprland config that starts a
&lt;a href="https://sw.kovidgoyal.net/kitty/"&gt;Kitty&lt;/a&gt; terminal emulator, that then launches
a shell script that runs the test. Since we have no way to get the results of
the test, we pipe the output to a file that we can collect later (e.g.:
&lt;code&gt;machine.succeded(&amp;quot;cat /home/alice/test.log&amp;quot;)&lt;/code&gt;). And once the script exit, we
create the canary file &lt;code&gt;$HOME/test-finished&lt;/code&gt;, that allows the &lt;code&gt;testScript&lt;/code&gt;
knows that the test finished and it can destroy the VM safely.&lt;/p&gt;
&lt;p&gt;If you want to take a look at the final result, it is
&lt;a href="https://github.com/thiagokokada/hyprland-go/blob/v0.0.1/flake.nix"&gt;here&lt;/a&gt;. This
tests run in any Linux machine that supports KVM, and also works in &lt;a href="https://github.com/thiagokokada/hyprland-go/actions/workflows/nix.yaml"&gt;GitHub
Actions&lt;/a&gt;
thanks to the the
&lt;a href="https://github.com/DeterminateSystems/nix-installer-action"&gt;nix-installer-action&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And now I have a proper CI pipeline in a way that I never imagined would be
possible, especially considering how simple it was.&lt;/p&gt;
</description>
			<link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</link>
			<pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
		</item>
	</channel>
</rss>