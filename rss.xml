<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kokada&#39;s blog</title>
    <link></link>
    <description># dd if=/dev/urandom of=/dev/brain0</description>
    <item>
      <title>Quick bits: realise Nix symlinks</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-08-01/02-quick-bits-realise-nix-symlinks.md</link>
      <description>&lt;p&gt;When you are using Nix, especially with&#xA;&lt;a href=&#34;https://github.com/nix-community/home-manager/&#34;&gt;Home-Manager&lt;/a&gt;, there are times&#xA;when you want to test something or maybe debug some issue in your&#xA;configuration. Those times it would be really convenient if you could avoid a&#xA;rebuild of your Home-Manager configuration, since this takes time until&#xA;evaluation and activation.&lt;/p&gt;&#xA;&lt;p&gt;For those times I have this small script in my Nix configuration called&#xA;&lt;code&gt;realise-symlinks&lt;/code&gt;, that is defined as:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ pkgs, ... }:&#xA;let&#xA;  realise-symlink = pkgs.writeShellApplication {&#xA;    name = &amp;quot;realise-symlink&amp;quot;;&#xA;    runtimeInputs = with pkgs; [ coreutils ];&#xA;    text = &#39;&#39;&#xA;      for file in &amp;quot;$@&amp;quot;; do&#xA;        if [[ -L &amp;quot;$file&amp;quot; ]]; then&#xA;          if [[ -d &amp;quot;$file&amp;quot; ]]; then&#xA;            tmpdir=&amp;quot;&#39;&#39;${file}.tmp&amp;quot;&#xA;            mkdir -p &amp;quot;$tmpdir&amp;quot;&#xA;            cp --verbose --recursive &amp;quot;$file&amp;quot;/* &amp;quot;$tmpdir&amp;quot;&#xA;            unlink &amp;quot;$file&amp;quot;&#xA;            mv &amp;quot;$tmpdir&amp;quot; &amp;quot;$file&amp;quot;&#xA;            chmod --changes --recursive +w &amp;quot;$file&amp;quot;&#xA;          else&#xA;            cp --verbose --remove-destination &amp;quot;$(readlink &amp;quot;$file&amp;quot;)&amp;quot; &amp;quot;$file&amp;quot;&#xA;            chmod --changes +w &amp;quot;$file&amp;quot;&#xA;          fi&#xA;        else&#xA;          &amp;gt;&amp;amp;2 echo &amp;quot;Not a symlink: $file&amp;quot;&#xA;          exit 1&#xA;        fi&#xA;      done&#xA;    &#39;&#39;;&#xA;  };&#xA;in&#xA;{&#xA;  home.packages = [ realise-symlink ];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The idea of this script is that you can call it against a symlink against Nix&#xA;store and it will realise, e.g.: convert to an &amp;quot;actual&amp;quot; file, e.g.:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ls -lah .zshrc&#xA;lrwxrwxrwx 1 thiagoko users 69 Aug  1 00:10 .zshrc -&amp;gt; /nix/store/glz018yyh0qfqc9lywx1yhr7c3l96lv7-home-manager-files/.zshrc&#xA;&#xA;$ realise-symlink .zshrc&#xA;removed &#39;.zshrc&#39;&#xA;&#39;/nix/store/glz018yyh0qfqc9lywx1yhr7c3l96lv7-home-manager-files/.zshrc&#39; -&amp;gt; &#39;.zshrc&#39;&#xA;mode of &#39;.zshrc&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;&#xA;$ ls -lah .zshrc&#xA;-rw-r--r-- 1 thiagoko users 5.8K Aug  1 00:16 .zshrc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;It also add write permissions to the resulting file, to make it easier to edit.&#xA;By the way, it also works with directories:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ls -lah zim-completion&#xA;lrwxrwxrwx 1 thiagoko users 90 Aug  1 00:10 zim-completion -&amp;gt; /nix/store/glz018yyh0qfqc9lywx1yhr7c3l96lv7-home-manager-files/.zsh/plugins/zim-completion&#xA;&#xA;$ realise-symlink zim-completion&#xA;&#39;zim-completion/init.zsh&#39; -&amp;gt; &#39;zim-completion.tmp/init.zsh&#39;&#xA;&#39;zim-completion/init.zsh.zwc&#39; -&amp;gt; &#39;zim-completion.tmp/init.zsh.zwc&#39;&#xA;&#39;zim-completion/LICENSE&#39; -&amp;gt; &#39;zim-completion.tmp/LICENSE&#39;&#xA;&#39;zim-completion/README.md&#39; -&amp;gt; &#39;zim-completion.tmp/README.md&#39;&#xA;mode of &#39;zim-completion/init.zsh&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;mode of &#39;zim-completion/init.zsh.zwc&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;mode of &#39;zim-completion/LICENSE&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;mode of &#39;zim-completion/README.md&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;&#xA;$ ls -lah zim-completion&#xA;total 28K&#xA;drwxr-xr-x 1 thiagoko users   72 Aug  1 00:18 .&#xA;drwxr-xr-x 1 thiagoko users  130 Aug  1 00:18 ..&#xA;-rw-r--r-- 1 thiagoko users 5.3K Aug  1 00:18 init.zsh&#xA;-rw-r--r-- 1 thiagoko users  12K Aug  1 00:18 init.zsh.zwc&#xA;-rw-r--r-- 1 thiagoko users 1.3K Aug  1 00:18 LICENSE&#xA;-rw-r--r-- 1 thiagoko users 2.2K Aug  1 00:18 README.md&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;After you finish whatever you are testing, to return to your configuration you&#xA;can just delete those files and re-run your Home-Manager activation:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rm -rf .zshrc&#xA;&#xA;$ sudo systemctl restart home-manager-&amp;lt;user&amp;gt;.service # or `home-manager switch`&#xA;&#xA;$ ls -lah .zshrc&#xA;lrwxrwxrwx 1 thiagoko users 69 Aug  1 00:20 .zshrc -&amp;gt; /nix/store/glz018yyh0qfqc9lywx1yhr7c3l96lv7-home-manager-files/.zshrc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;It even works with system files:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo realise-symlink /etc/nix/nix.conf&#xA;[sudo] password for thiagoko:&#xA;removed &#39;nix.conf&#39;&#xA;&#39;/etc/static/nix/nix.conf&#39; -&amp;gt; &#39;nix.conf&#39;&#xA;mode of &#39;nix.conf&#39; changed from 0444 (r--r--r--) to 0644 (rw-r--r--)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;But I never needed for this case since it is more rare to me to experiment with&#xA;OS level configuration.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-08-01/02-quick-bits-realise-nix-symlinks.md</guid>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Troubleshoting: ZSH lag and solutions with Nix</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-08-01/01-troubleshooting-zsh-lag-and-solutions-with-nix.md</link>
      <description>&lt;p&gt;Inspired by this &lt;a href=&#34;https://lock.cmpxchg8b.com/slowterm.html&#34;&gt;blog post from&#xA;Tavis&lt;/a&gt;, I decided to document my own&#xA;recent journey of reducing terminal (ZSH) lag startup. This post is way less&#xA;interesting than the one from Tavis that uses a debugger to patch applications&#xA;on the fly, but should still be interesting for some. And it also shows how&#xA;powerful Nix can be for some things.&lt;/p&gt;&#xA;&lt;p&gt;For context, I have basically 3 systems where I interact with terminal&#xA;frequently:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.notebookcheck.net/Lenovo-ThinkPad-P14s-Gen-1-Laptop-Review-AMD-workstation-sans-dedicated-GPU.528746.0.html&#34;&gt;Thinkpad P14s Gen 1&lt;/a&gt;&#xA;running NixOS, with a reasonable fast CPU (&lt;a href=&#34;https://www.notebookcheck.net/AMD-Ryzen-7-PRO-4750U-Processor-Benchmarks-and-Specs.464396.0.html&#34;&gt;AMD Ryzen 7 PRO&#xA;4750U&lt;/a&gt;)&#xA;and disk (NVMe)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://everymac.com/systems/apple/macbook_pro/specs/macbook-pro-m1-pro-10-core-cpu-16-core-gpu-16-2021-specs.html&#34;&gt;MacBook&#xA;Pro&lt;/a&gt;&#xA;with a really fast CPU (M1 Pro) and disk, but of course running macOS, being&#xA;phased-out since this is a job owned machine and I am changing jobs right&#xA;now, but should be replaced with another one soon™&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chromeunboxed.com/lenovo-chromebook-duet-3-review-perfect-sequel&#34;&gt;Chromebook Duet&#xA;3&lt;/a&gt;&#xA;running ChromeOS, with slow CPU (&lt;a href=&#34;https://www.notebookcheck.net/Qualcomm-Snapdragon-7c-Gen-2-Processor-Benchmarks-and-Specs.554426.0.html&#34;&gt;Snapdragon 7c Gen&#xA;2&lt;/a&gt;)&#xA;and disk (eMMC, really?)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;My experience is similar to Tavis, at around 300ms of startup time I don&#39;t care&#xA;too much, but around 500ms+ is where I start to notice. I never had any issues&#xA;with startup time in NixOS itself (I had issues with macOS before, but it was&#xA;not actually the fault of macOS), but in the Chromebook it was awful: 600ms+&#xA;with &lt;a href=&#34;https://www.instabug.com/blog/understanding-cold-hot-and-warm-app-launch-time&#34;&gt;hot&#xA;start&lt;/a&gt;,&#xA;while cold start it could take multiple seconds.&lt;/p&gt;&#xA;&lt;p&gt;We can check how long ZSH takes to start by using:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ time zsh -ci exit&#xA;zsh -ic exit  0.04s user 0.10s system 100% cpu 0.143 total&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;-i&lt;/code&gt; flag here is important, because we are interested in the interactive&#xA;use of ZSH. Without this flag ZSH will ignore your &lt;code&gt;~/.zshrc&lt;/code&gt; file, and the&#xA;results will be meaningless.&lt;/p&gt;&#xA;&lt;p&gt;To do a more interesting benchmark, we can use&#xA;&lt;a href=&#34;https://github.com/sharkdp/hyperfine&#34;&gt;&lt;code&gt;hyperfine&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     145.4 ms ±   4.2 ms    [User: 49.8 ms, System: 97.3 ms]&#xA;  Range (min … max):   138.6 ms … 155.3 ms    19 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Hyperfine will run the command multiple times and take care of things like&#xA;shell startup time. A really great tool to have in your toolbox by the way, but&#xA;I digress.&lt;/p&gt;&#xA;&lt;p&gt;So let&#39;s do a little time travelling. Going back to commit&#xA;&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/tree/b12757f90889653e359a1ab0a8cfd2f90cfabf31&#34;&gt;&lt;code&gt;b12757f&lt;/code&gt;&lt;/a&gt;&#xA;from &lt;a href=&#34;https://github.com/thiagokokada/nix-configs/&#34;&gt;nix-configs&lt;/a&gt;. Running&#xA;&lt;code&gt;hyperfine&lt;/code&gt; like above from my NixOS laptop, we have:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     218.6 ms ±   5.1 ms    [User: 70.6 ms, System: 151.5 ms]&#xA;  Range (min … max):   210.3 ms … 227.0 ms    13 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This doesn&#39;t look that bad, but let&#39;s see the same commit in my Chromebook:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     679.7 ms ±  40.2 ms    [User: 230.8 ms, System: 448.5 ms]&#xA;  Range (min … max):   607.3 ms … 737.0 ms    10 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Yikes, this is much worse. And those are the results after I retried the&#xA;benchmark (so it is a hot start). The cold start times were above 3s. So let&#39;s&#xA;investigate what is happening here. We can profile what is taking time during&#xA;the startup of ZSH using &lt;a href=&#34;https://www.bigbinary.com/blog/zsh-profiling&#34;&gt;zprof&lt;/a&gt;.&#xA;You can add the following in your &lt;code&gt;~/.zshrc&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# At the top of your ~/.zshrc file&#xA;zmodload zsh/zprof&#xA;&#xA;# ...&#xA;&#xA;# At the end of your ~/.zshrc file&#xA;zprof&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Or if using Home-Manager, use the&#xA;&lt;a href=&#34;https://nix-community.github.io/home-manager/options.xhtml#opt-programs.zsh.zprof.enable&#34;&gt;&lt;code&gt;programs.zsh.zprof.enable&lt;/code&gt;&lt;/a&gt;&#xA;option. Once we restart ZSH, we will have something like:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;num  calls                time                       self            name&#xA;-----------------------------------------------------------------------------------&#xA; 1)    1          36.91    36.91   34.29%     30.47    30.47   28.31%  (anon) [/home/thiagoko/.zsh/plugins/zim-completion/init.zsh:13]&#xA; 2)    1          25.43    25.43   23.63%     25.43    25.43   23.63%  (anon) [/home/thiagoko/.zsh/plugins/zim-ssh/init.zsh:6]&#xA; 3)    1          22.00    22.00   20.45%     21.92    21.92   20.36%  _zsh_highlight_load_highlighters&#xA; 4)    1          12.32    12.32   11.45%     12.32    12.32   11.45%  autopair-init&#xA; 5)    1           6.44     6.44    5.98%      6.44     6.44    5.98%  compinit&#xA; 6)    1           3.56     3.56    3.31%      3.48     3.48    3.23%  prompt_pure_state_setup&#xA; 7)    2           3.79     1.89    3.52%      2.85     1.43    2.65%  async&#xA; 8)    1           0.93     0.93    0.87%      0.93     0.93    0.87%  async_init&#xA; 9)    6           0.93     0.15    0.86%      0.93     0.15    0.86%  is-at-least&#xA;10)    6           0.67     0.11    0.63%      0.67     0.11    0.63%  add-zle-hook-widget&#xA;11)    1           8.25     8.25    7.66%      0.61     0.61    0.57%  prompt_pure_setup&#xA;12)    1           0.40     0.40    0.37%      0.40     0.40    0.37%  (anon) [/nix/store/p1zqypy7600fvfyl1v571bljx2l8zhay-zsh-autosuggestions-0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh:458]&#xA;13)    5           0.31     0.06    0.29%      0.31     0.06    0.29%  add-zsh-hook&#xA;14)    1           0.60     0.60    0.56%      0.29     0.29    0.27%  (anon) [/home/thiagoko/.zsh/plugins/zim-input/init.zsh:5]&#xA;15)    1           0.21     0.21    0.20%      0.21     0.21    0.20%  compdef&#xA;16)    1           0.10     0.10    0.09%      0.10     0.10    0.09%  _zsh_highlight__function_is_autoload_stub_p&#xA;17)    1           0.26     0.26    0.24%      0.08     0.08    0.08%  _zsh_highlight__function_callable_p&#xA;18)    1           0.08     0.08    0.08%      0.08     0.08    0.08%  prompt_pure_is_inside_container&#xA;19)    1           0.07     0.07    0.07%      0.07     0.07    0.07%  _zsh_highlight__is_function_p&#xA;20)    1           0.01     0.01    0.01%      0.01     0.01    0.01%  __wezterm_install_bash_prexec&#xA;21)    1           0.00     0.00    0.00%      0.00     0.00    0.00%  _zsh_highlight_bind_widgets&#xA;# ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I ommited some output for brevit. The first 2 things that shows are from the&#xA;&lt;a href=&#34;https://github.com/zimfw/zimfw&#34;&gt;zimfw&lt;/a&gt;, the framework that I use to configure&#xA;my ZSH (similar to Oh-My-Zsh). I actually don&#39;t use &lt;code&gt;zimfw&lt;/code&gt; directly, instead I&#xA;just load some modules that I find useful, like the &lt;code&gt;zim-completion&lt;/code&gt; and&#xA;&lt;code&gt;zim-ssh&lt;/code&gt; that we can see above. By the way, Zim is generally really well&#xA;optimised for startup time, but those 2 modules are kind slow.&lt;/p&gt;&#xA;&lt;p&gt;For &lt;a href=&#34;https://github.com/zimfw/completion&#34;&gt;&lt;code&gt;zim-completion&lt;/code&gt;&lt;/a&gt;, after taking a&#xA;look at it, there isn&#39;t much I could do. It seems that the reason&#xA;&lt;code&gt;zim-completion&lt;/code&gt; takes so long during startup is because it is trying to decide&#xA;if it needs to recompile the completions (and replacing it with just a naive&#xA;&lt;code&gt;autoload -U compinit &amp;amp;&amp;amp; compinit&lt;/code&gt; is even worse for startup performance). I&#xA;may eventually replace it for something else, but I really like what Zim brings&#xA;here, so I decided to not touch it for now.&lt;/p&gt;&#xA;&lt;p&gt;However &lt;a href=&#34;https://github.com/zimfw/ssh&#34;&gt;&lt;code&gt;zim-ssh&lt;/code&gt;&lt;/a&gt; is another history. The only&#xA;reason I used it is to start a &lt;code&gt;ssh-agent&lt;/code&gt; and keep it between multiple ZSH&#xA;sessions. It shouldn&#39;t have that much influence in startup time. So I took a&#xA;look the code (since it is small, I am reproducing it here):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#&#xA;# Set up ssh-agent&#xA;#&#xA;&#xA;# Don&#39;t do anything unless we can actually use ssh-agent&#xA;(( ${+commands[ssh-agent]} )) &amp;amp;&amp;amp; () {&#xA;  ssh-add -l &amp;amp;&amp;gt;/dev/null&#xA;  if (( ? == 2 )); then&#xA;    # Unable to contact the authentication agent&#xA;&#xA;    # Load stored agent connection info&#xA;    local -r ssh_env=${HOME}/.ssh-agent&#xA;    if [[ -r ${ssh_env} ]] source ${ssh_env} &amp;gt;/dev/null&#xA;&#xA;    ssh-add -l &amp;amp;&amp;gt;/dev/null&#xA;    if (( ? == 2 )); then&#xA;        # Start agent and store agent connection info&#xA;        (umask 066; ssh-agent &amp;gt;! ${ssh_env})&#xA;        source ${ssh_env} &amp;gt;/dev/null&#xA;    fi&#xA;  fi&#xA;&#xA;  # Load identities&#xA;  ssh-add -l &amp;amp;&amp;gt;/dev/null&#xA;  if (( ? == 1 )); then&#xA;    local -a zssh_ids&#xA;    zstyle -a &#39;:zim:ssh&#39; ids &#39;zssh_ids&#39;&#xA;    if (( ${#zssh_ids} )); then&#xA;      ssh-add ${HOME}/.ssh/${^zssh_ids} 2&amp;gt;/dev/null&#xA;    else&#xA;      ssh-add 2&amp;gt;/dev/null&#xA;    fi&#xA;  fi&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Well, this is bad. Let&#39;s assume the common path, where the &lt;code&gt;ssh-agent&lt;/code&gt; is&#xA;already running but you open a new shell instance (that doesn&#39;t have the&#xA;connection info yet so it will need to load). This will run &lt;code&gt;ssh-add&lt;/code&gt; at 4&#xA;times. How long does &lt;code&gt;ssh-add&lt;/code&gt; takes to run?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine -Ni &amp;quot;ssh-add -l&amp;quot;&#xA;Benchmark 1: ssh-add -l&#xA;  Time (mean ± σ):       4.6 ms ±   1.1 ms    [User: 2.0 ms, System: 2.0 ms]&#xA;  Range (min … max):     3.4 ms …   8.7 ms    619 runs&#xA;&#xA;  Warning: Ignoring non-zero exit code.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For those curious, &lt;code&gt;-N&lt;/code&gt; disables the Shell usage, that works better when the&#xA;command being tested is too fast.&lt;/p&gt;&#xA;&lt;p&gt;In average we have 4x4ms=16ms of startup time. But keep in mind the worst case&#xA;can be much worse. The question is, how can we improve the situation here?&lt;/p&gt;&#xA;&lt;p&gt;After taking a look, I decided to write my own code, based in some ideas stolen&#xA;from &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh/blob/67581c53c6458566e174620361e84b364b9034d2/plugins/ssh-agent/ssh-agent.plugin.zsh&#34;&gt;Oh-My-Zsh ssh-agent&#xA;plugin&lt;/a&gt;.&#xA;Here is final version of my&#xA;&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/blob/e45a888f2bf3ce5644c3966f0b6371414d0291e2/home-manager/cli/ssh/ssh-agent.zsh&#34;&gt;code&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;zmodload zsh/net/socket&#xA;&#xA;_check_agent(){&#xA;  if [[ -S &amp;quot;$SSH_AUTH_SOCK&amp;quot; ]] &amp;amp;&amp;amp; zsocket &amp;quot;$SSH_AUTH_SOCK&amp;quot; 2&amp;gt;/dev/null; then&#xA;    return 0&#xA;  fi&#xA;  return 1&#xA;}&#xA;&#xA;_start_agent() {&#xA;  # Test if $SSH_AUTH_SOCK is visible, in case we start e.g.: ssh-agent via&#xA;  # systemd service&#xA;  if _check_agent; then&#xA;    return 0&#xA;  fi&#xA;&#xA;  # Get the filename to store/lookup the environment from&#xA;  local -r ssh_env_cache=&amp;quot;$HOME/.ssh-agent&amp;quot;&#xA;&#xA;  # Check if ssh-agent is already running&#xA;  if [[ -f &amp;quot;$ssh_env_cache&amp;quot; ]]; then&#xA;    source &amp;quot;$ssh_env_cache&amp;quot; &amp;gt; /dev/null&#xA;&#xA;    # Test if $SSH_AUTH_SOCK is visible, e.g.: the ssh-agent is still alive&#xA;    if _check_agent; then&#xA;      return 0&#xA;    fi&#xA;  fi&#xA;&#xA;  # start ssh-agent and setup environment&#xA;  (&#xA;    umask 066&#xA;    ssh-agent -s &amp;gt;! &amp;quot;$ssh_env_cache&amp;quot;&#xA;  )&#xA;  source &amp;quot;$ssh_env_cache&amp;quot; &amp;gt; /dev/null&#xA;}&#xA;&#xA;_start_agent&#xA;unfunction _check_agent _start_agent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The idea here is simple: using&#xA;&lt;a href=&#34;https://zsh.sourceforge.io/Doc/Release/Zsh-Modules.html#The-zsh_002fnet_002fsocket-Module&#34;&gt;&lt;code&gt;zsocket&lt;/code&gt;&lt;/a&gt;&#xA;module from ZSH itself to check if the &lt;code&gt;ssh-agent&lt;/code&gt; is working instead of&#xA;executing &lt;code&gt;ssh-add -l&lt;/code&gt;. The only case we run any program now is to start the&#xA;agent itself if needed. Let&#39;s run &lt;code&gt;hyperfine&lt;/code&gt; again:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     188.3 ms ±   8.2 ms    [User: 61.1 ms, System: 130.0 ms]&#xA;  Range (min … max):   170.9 ms … 198.4 ms    16 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Got a good improvement here already. Let&#39;s see &lt;code&gt;zprof&lt;/code&gt; again:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;num  calls                time                       self            name&#xA;-----------------------------------------------------------------------------------&#xA; 1)    1          41.23    41.23   48.66%     33.52    33.52   39.56%  (anon) [/home/thiagoko/.zsh/plugins/zim-completion/init.zsh:13]&#xA; 2)    1          22.23    22.23   26.24%     22.12    22.12   26.10%  _zsh_highlight_load_highlighters&#xA; 3)    1           8.90     8.90   10.51%      8.90     8.90   10.51%  Gautopair-init&#xA; 4)    1           7.71     7.71    9.10%      7.71     7.71    9.10%  compinit&#xA; 5)    1           5.74     5.74    6.77%      5.60     5.60    6.60%  prompt_pure_state_setup&#xA; 6)    6           1.19     0.20    1.41%      1.19     0.20    1.41%  add-zle-hook-widget&#xA; 7)    2           1.97     0.99    2.33%      1.14     0.57    1.34%  async&#xA; 8)    6           0.87     0.15    1.03%      0.87     0.15    1.03%  is-at-least&#xA; 9)    1           0.84     0.84    0.99%      0.84     0.84    0.99%  async_init&#xA;10)    1           9.30     9.30   10.97%      0.72     0.72    0.84%  prompt_pure_setup&#xA;11)    5           0.63     0.13    0.75%      0.63     0.13    0.75%  add-zsh-hook&#xA;12)    1           0.41     0.41    0.48%      0.41     0.41    0.48%  _start_agent&#xA;13)    1           0.31     0.31    0.37%      0.31     0.31    0.37%  (anon) [/nix/store/p1zqypy7600fvfyl1v571bljx2l8zhay-zsh-autosuggestions-0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh:458]&#xA;14)    1           0.55     0.55    0.64%      0.24     0.24    0.28%  (anon) [/home/thiagoko/.zsh/plugins/zim-input/init.zsh:5]&#xA;15)    1           0.14     0.14    0.16%      0.14     0.14    0.16%  prompt_pure_is_inside_container&#xA;16)    1           0.14     0.14    0.16%      0.14     0.14    0.16%  compdef&#xA;17)    1           0.09     0.09    0.11%      0.09     0.09    0.11%  _zsh_highlight__function_is_autoload_stub_p&#xA;18)    1           0.25     0.25    0.29%      0.08     0.08    0.09%  _zsh_highlight__function_callable_p&#xA;19)    1           0.07     0.07    0.09%      0.07     0.07    0.09%  _zsh_highlight__is_function_p&#xA;20)    1           0.01     0.01    0.01%      0.01     0.01    0.01%  __wezterm_install_bash_prexec&#xA;21)    1           0.01     0.01    0.01%      0.01     0.01    0.01%  _zsh_highlight_bind_widgets&#xA;# ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Well, there is nothing interesting here anymore. I mean, &lt;code&gt;zim-completion&lt;/code&gt; is&#xA;still the main culprit, but nothing to do for now. Instead of looking at&#xA;&lt;code&gt;zproof&lt;/code&gt;, let&#39;s take a look at my &lt;code&gt;~/.zshrc&lt;/code&gt; instead:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# ...&#xA;if [[ $options[zle] = on ]]; then&#xA;  eval &amp;quot;$(/nix/store/sk6wsgp4h477baxypksz9rl8ldwwh9yg-fzf-0.54.0/bin/fzf --zsh)&amp;quot;&#xA;fi&#xA;&#xA;# ...&#xA;/nix/store/x3yblr73r5x76dmaanjk3333mvzxc49r-any-nix-shell-1.2.1/bin/any-nix-shell zsh | source /dev/stdin&#xA;&#xA;# ...&#xA;eval &amp;quot;$(/nix/store/330d6k81flfs6w46b44afmncxk57qggv-zoxide-0.9.4/bin/zoxide init zsh )&amp;quot;&#xA;&#xA;# ...&#xA;eval &amp;quot;$(/nix/store/8l9j9kdv9m0z0s30lp4yvrc9s5bcbgmx-direnv-2.34.0/bin/direnv hook zsh)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So you see, starting all those programs during ZSH startup can hurt the shell&#xA;startup considerable. Not necessary for commands fast like &lt;code&gt;fzf&lt;/code&gt; (that is&#xA;written in Go), but let&#39;s see&#xA;&lt;a href=&#34;https://github.com/haslersn/any-nix-shell&#34;&gt;&lt;code&gt;any-nix-shell&lt;/code&gt;&lt;/a&gt;, that is written&#xA;in shell script:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine &amp;quot;any-nix-shell zsh&amp;quot;&#xA;Benchmark 1: any-nix-shell zsh&#xA;  Time (mean ± σ):      16.0 ms ±   1.8 ms    [User: 5.6 ms, System: 10.5 ms]&#xA;  Range (min … max):    11.3 ms …  20.3 ms    143 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is bad, consistently bad actually. Even for commands that are fast, keep&#xA;in mind that there is a difference between the cold and hot start again. For&#xA;example, &lt;code&gt;fzf&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ hyperfine -N &amp;quot;fzf --zsh&amp;quot;&#xA;Benchmark 1: fzf --zsh&#xA;  Time (mean ± σ):       2.9 ms ±   0.9 ms    [User: 0.6 ms, System: 2.3 ms]&#xA;  Range (min … max):     1.7 ms …   6.8 ms    1113 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;See the range? While 1.7ms is something that is probably difficult to notice,&#xA;6.8ms can be noticiable, especially if this accumulates with other slow&#xA;starting apps.&lt;/p&gt;&#xA;&lt;p&gt;And the thing is, all those commands are just generating in the end a fixed&#xA;output, at least for the current version of the program. Can we pre-generate&#xA;them instead? If using Nix, of course we can:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;programs.zsh.initExtra =&#xA;  # bash&#xA;  &#39;&#39;&#xA;    # any-nix-shell&#xA;    source ${&#xA;      pkgs.runCommand &amp;quot;any-nix-shell-zsh&amp;quot; { } &#39;&#39;&#xA;        ${lib.getExe pkgs.any-nix-shell} zsh &amp;gt; $out&#xA;      &#39;&#39;&#xA;    }&#xA;&#xA;    # fzf&#xA;    source ${config.programs.fzf.package}/share/fzf/completion.zsh&#xA;    source ${config.programs.fzf.package}/share/fzf/key-bindings.zsh&#xA;&#xA;    # zoxide&#xA;    source ${&#xA;      pkgs.runCommand &amp;quot;zoxide-init-zsh&amp;quot; { } &#39;&#39;&#xA;        ${lib.getExe config.programs.zoxide.package} init zsh &amp;gt; $out&#xA;      &#39;&#39;&#xA;    }&#xA;&#xA;    # direnv&#xA;    source ${&#xA;      pkgs.runCommand &amp;quot;direnv-hook-zsh&amp;quot; { } &#39;&#39;&#xA;        ${lib.getExe config.programs.direnv.package} hook zsh &amp;gt; $out&#xA;      &#39;&#39;&#xA;    }&#xA;  &#39;&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So we can use &lt;code&gt;pkgs.runCommand&lt;/code&gt; to run those commands during build time and&#xA;&lt;code&gt;source&lt;/code&gt; the result. &lt;code&gt;fzf&lt;/code&gt; actually doesn&#39;t need this since we have the files&#xA;already generated in the package. I think this is one of those things that&#xA;really shows the power of Nix: I wouldn&#39;t do something similar if I didn&#39;t use&#xA;Nix because the risk of breaking something later is big (e.g.: forgetting to&#xA;update the generated files), but Nix makes those things trivial.&lt;/p&gt;&#xA;&lt;p&gt;Let&#39;s run &lt;code&gt;hyperfine&lt;/code&gt; again:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     162.3 ms ±   4.9 ms    [User: 52.7 ms, System: 111.1 ms]&#xA;  Range (min … max):   153.0 ms … 173.4 ms    19 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Another good improvement. The last change I did is switching between&#xA;&lt;a href=&#34;https://github.com/zsh-users/zsh-syntax-highlighting&#34;&gt;&lt;code&gt;zsh-syntax-highlighting&lt;/code&gt;&lt;/a&gt;&#xA;to&#xA;&lt;a href=&#34;https://github.com/zdharma-continuum/fast-syntax-highlighting&#34;&gt;&lt;code&gt;zsh-fast-syntax-highlighting&lt;/code&gt;&lt;/a&gt;,&#xA;that is supposed to be faster and have better highlighting too. I got that from&#xA;&lt;code&gt;_zsh_highlight_load_highlighters&lt;/code&gt; using 26% of the time from my &lt;code&gt;zprof&lt;/code&gt; above.&#xA;And for the final &lt;code&gt;hyperfine&lt;/code&gt; in my laptop:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     138.3 ms ±   7.1 ms    [User: 47.5 ms, System: 91.9 ms]&#xA;  Range (min … max):   123.8 ms … 157.9 ms    21 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A ~36% improvement, not bad. Let&#39;s see how it fares in my Chromebook:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ hyperfine &amp;quot;zsh -ic exit&amp;quot;&#xA;Benchmark 1: zsh -ic exit&#xA;  Time (mean ± σ):     278.2 ms ±  46.9 ms    [User: 88.0 ms, System: 184.8 ms]&#xA;  Range (min … max):   204.7 ms … 368.5 ms    11 runs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;An even more impressive ~59% improvement. And yes, the shell startup now feels&#xA;much better.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-08-01/01-troubleshooting-zsh-lag-and-solutions-with-nix.md</guid>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Generating YAML files with Nix</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-31/01-generating-yaml-files-with-nix.md</link>
      <description>&lt;p&gt;I hate YAML. Instead of writing an essay on why I hate YAML, I can just link to&#xA;&lt;a href=&#34;https://noyaml.com/&#34;&gt;noyaml.com&lt;/a&gt;. In my personal projects I will never use it,&#xA;preferring either JSON, &lt;a href=&#34;https://toml.io/en/&#34;&gt;TOML&lt;/a&gt; or even plain old&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/INI_file&#34;&gt;INI&lt;/a&gt; files depending on the use case.&#xA;However the ship has sailed already, there are tons of projects everywhere that&#xA;uses YAML: from most CI systems (&lt;a href=&#34;https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions&#34;&gt;GitHub&#xA;Actions&lt;/a&gt;,&#xA;&lt;a href=&#34;https://circleci.com/docs/introduction-to-yaml-configurations/&#34;&gt;CircleCI&lt;/a&gt;,&#xA;&lt;a href=&#34;https://docs.travis-ci.com/user/build-config-yaml&#34;&gt;Travis&lt;/a&gt;, et tu&#xA;&lt;a href=&#34;https://man.sr.ht/builds.sr.ht/&#34;&gt;builds.sr.ht&lt;/a&gt;, to&#xA;&lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/&#34;&gt;Kubernetes&lt;/a&gt;,&#xA;or in almost every&#xA;&lt;a href=&#34;https://guides.rubyonrails.org/configuring.html#configuring-a-database&#34;&gt;Rails&lt;/a&gt;&#xA;application.&lt;/p&gt;&#xA;&lt;p&gt;One way to avoid at least some issues with the language is to write YAML in&#xA;another language. I will show my solution in one of my &lt;a href=&#34;https://github.com/thiagokokada/nix-configs/&#34;&gt;personal&#xA;repositories&lt;/a&gt;, writing Nix to&#xA;generate GitHub Actions configuration files. Bonus points for validating the&#xA;result against the schema of GitHub Actions, so the famous &amp;quot;this is supposed to&#xA;be string instead of a list of strings&amp;quot; is gone.&lt;/p&gt;&#xA;&lt;p&gt;Let&#39;s start with the basics: YAML is supposed to be a &lt;a href=&#34;https://stackoverflow.com/a/1729545&#34;&gt;superset of&#xA;JSON&lt;/a&gt;. What that means is that a JSON file&#xA;&lt;a href=&#34;https://yaml.org/spec/1.2-old/spec.html#id2759572&#34;&gt;can be parsed&lt;/a&gt; by a YAML&#xA;parser. And Nix itself generates JSON natively, after all, Nix can be imagined&#xA;as &lt;a href=&#34;https://nix.dev/tutorials/nix-language.html&#34;&gt;&amp;quot;JSON with functions&amp;quot;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;To make things easier, I will assume that you have the &lt;code&gt;nix-commands&lt;/code&gt; and&#xA;&lt;code&gt;flakes&lt;/code&gt; enabled as &lt;code&gt;experimental-features&lt;/code&gt; in your Nix configuration. If not,&#xA;go &lt;a href=&#34;https://wiki.nixos.org/wiki/Flakes&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Using the &lt;code&gt;nix eval&lt;/code&gt; command, we can generate a JSON expression from Nix by:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nix eval --expr &#39;{ foo = &amp;quot;bar&amp;quot;; }&#39; --json&#xA;{&amp;quot;foo&amp;quot;:&amp;quot;bar&amp;quot;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;However, typing long excerpts of Nix code inside the console would be&#xA;impractical. We can write the following code inside a &lt;code&gt;foo.nix&lt;/code&gt; file instead:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  foo = &amp;quot;bar&amp;quot;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nix eval --file foo.nix --json&#xA;{&amp;quot;foo&amp;quot;:&amp;quot;bar&amp;quot;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;While you can use a JSON output as an input for YAML parsers, it is probably&#xA;not the &lt;a href=&#34;https://metacpan.org/pod/JSON::XS#JSON-and-YAML&#34;&gt;best idea&lt;/a&gt;. Sadly (or&#xA;maybe not), Nix has no native functionality to export data to YAML. However,&#xA;since we are using Nix, it is trivial to use &lt;code&gt;nixpkgs&lt;/code&gt; to use some program to&#xA;convert from JSON to YAML.&lt;/p&gt;&#xA;&lt;p&gt;To start, let&#39;s create a new directory, move our &lt;code&gt;foo.nix&lt;/code&gt; file to it, create a&#xA;new &lt;code&gt;flake.nix&lt;/code&gt; file and put the following contents:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  description = &amp;quot;Generate YAML files with Nix&amp;quot;;&#xA;&#xA;  inputs = {&#xA;    nixpkgs.url = &amp;quot;github:NixOS/nixpkgs/nixos-unstable&amp;quot;;&#xA;  };&#xA;&#xA;  outputs = { nixpkgs, ... }:&#xA;    {&#xA;      packages.x86_64-linux =&#xA;        let&#xA;          inherit (nixpkgs) lib;&#xA;          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };&#xA;        in&#xA;        {&#xA;          toYAML = pkgs.runCommand &amp;quot;toYAML&amp;quot; {&#xA;            buildInputs = with pkgs; [ yj ];&#xA;            json = builtins.toJSON (import ./go.nix);&#xA;            passAsFile = [ &amp;quot;json&amp;quot; ]; # will be available as `$jsonPath`&#xA;          } &#39;&#39;&#xA;            mkdir -p $out&#xA;            yj -jy &amp;lt; &amp;quot;$jsonPath&amp;quot; &amp;gt; $out/go.yaml&#xA;          &#39;&#39;;&#xA;        };&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We are loading the &lt;code&gt;./foo.nix&lt;/code&gt; as a Nix file, converting it to JSON with&#xA;&lt;code&gt;builtins.toJSON&lt;/code&gt; function, and finally, using &lt;code&gt;pkgs.runCommand&lt;/code&gt; and its&#xA;&lt;code&gt;passAsFile&lt;/code&gt; option to load the contents of the JSON file into&#xA;&lt;a href=&#34;https://github.com/sclevine/yj&#34;&gt;yj&lt;/a&gt;, that converts between serialisation&#xA;formats (&lt;code&gt;-jy&lt;/code&gt; flag means &amp;quot;JSON to YAML&amp;quot;). The reason I choose &lt;code&gt;yj&lt;/code&gt; is mostly&#xA;because it is a single binary Go program, but you can use whatever you prefer.&lt;/p&gt;&#xA;&lt;p&gt;By the way, there is a&#xA;&lt;a href=&#34;https://github.com/NixOS/nixpkgs/blob/9f918d616c5321ad374ae6cb5ea89c9e04bf3e58/lib/generators.nix#L805&#34;&gt;&lt;code&gt;lib.generators.toYAML&lt;/code&gt;&lt;/a&gt;&#xA;inside &lt;code&gt;nixpkgs.lib&lt;/code&gt;, but as of the day of this post it only calls&#xA;&lt;code&gt;lib.strings.toJSON&lt;/code&gt; (that in turn, calls &lt;code&gt;builtins.toJSON&lt;/code&gt;). So it doesn&#39;t&#xA;really help here. Another option would be &lt;code&gt;pkgs.formats.yaml.generate&lt;/code&gt;, that&#xA;converts between formats, but it calls&#xA;&lt;a href=&#34;https://github.com/NixOS/nixpkgs/blob/008ceae1a2b47a84d7aa01e55f8468272c70b9ee/pkgs/pkgs-lib/formats.nix#L77-L84&#34;&gt;&lt;code&gt;remarshal&lt;/code&gt;&lt;/a&gt;&#xA;(in Python), so not my favorite choice.&lt;/p&gt;&#xA;&lt;p&gt;If we run the following commands, we can see the result:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nix build .#packages.x86_64-linux.toYAML&#xA;$ cat result/foo.yaml&#xA;foo: bar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That is the basic idea. To have a more realistic example, let&#39;s convert the&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/4e3f25485c6682f3e066b219df2290934bc0d256/.github/workflows/go.yml&#34;&gt;&lt;code&gt;go.yml&lt;/code&gt;&lt;/a&gt;,&#xA;that builds this blog, to Nix:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  name = &amp;quot;Go&amp;quot;;&#xA;  on.push.branches = [ &amp;quot;main&amp;quot; ];&#xA;&#xA;  jobs = {&#xA;    build = {&#xA;      runs-on = &amp;quot;ubuntu-latest&amp;quot;;&#xA;      permissions.contents = &amp;quot;write&amp;quot;;&#xA;      steps = [&#xA;        { uses = &amp;quot;actions/checkout@v4&amp;quot;; }&#xA;        {&#xA;          name = &amp;quot;Set up Go&amp;quot;;&#xA;          uses = &amp;quot;actions/checkout@v4&amp;quot;;&#xA;          &amp;quot;with&amp;quot;.go-version = &amp;quot;1.21&amp;quot;;&#xA;        }&#xA;        {&#xA;          name = &amp;quot;Update&amp;quot;;&#xA;          run = &amp;quot;make&amp;quot;;&#xA;        }&#xA;        {&#xA;          name = &amp;quot;Publish&amp;quot;;&#xA;          run = &amp;quot;make publish&amp;quot;;&#xA;          env.MATAROA_TOKEN = &#39;&#39;&#39;&#39;${{ secrets.MATAROA_TOKEN }}&#39;&#39;;&#xA;        }&#xA;        {&#xA;          name = &amp;quot;Commit&amp;quot;;&#xA;          uses = &amp;quot;stefanzweifel/git-auto-commit-action@v5&amp;quot;;&#xA;          &amp;quot;with&amp;quot;.commit_message = &amp;quot;README/rss:update&amp;quot;;&#xA;        }&#xA;      ];&#xA;    };&#xA;  };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Some interesting things to highlight: &lt;code&gt;with&lt;/code&gt; is a reserved word in Nix, so we&#xA;need to quote it. Not a problem, but something to be aware. And the template&#xA;string in GitHub Actions uses the same &lt;code&gt;${}&lt;/code&gt; that Nix uses, so we need to&#xA;escape.&lt;/p&gt;&#xA;&lt;p&gt;And after running the following commands:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ nix build .#packages.x86_64-linux.toYAML&#xA;$ cat result/go.yaml&#xA;jobs:&#xA;  build:&#xA;    permissions:&#xA;      contents: write&#xA;    runs-on: ubuntu-latest&#xA;    steps:&#xA;      - uses: actions/checkout@v4&#xA;      - name: Set up Go&#xA;        uses: actions/checkout@v4&#xA;        with:&#xA;          go-version: &amp;quot;1.21&amp;quot;&#xA;      - name: Update&#xA;        run: make&#xA;      - env:&#xA;          MATAROA_TOKEN: ${{ secrets.MATAROA_TOKEN }}&#xA;        name: Publish&#xA;        run: make publish&#xA;      - name: Commit&#xA;        uses: stefanzweifel/git-auto-commit-action@v5&#xA;        with:&#xA;          commit_message: README/rss:update&#xA;name: Go&#xA;&amp;quot;on&amp;quot;:&#xA;  push:&#xA;    branches:&#xA;      - main&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Yes, the keys are not in the same order as we defined, since Nix, like most&#xA;programming languages (with the exception of&#xA;&lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2017-December/151283.html&#34;&gt;Python&lt;/a&gt;),&#xA;do not guarantee the insertion order in maps/dicts/attrsets/whatever. But I&#xA;really hope whatever is consuming your YAML is not relying in the order the&#xA;keys are defined (this would be more cursed than YAML already is).&lt;/p&gt;&#xA;&lt;p&gt;So that is basically it. For the bonus points that I talked at the start of the&#xA;post, we can modify &lt;code&gt;pkgs.runCommand&lt;/code&gt; to run some kind of validator. I use&#xA;&lt;a href=&#34;https://github.com/mpalmer/action-validator&#34;&gt;&lt;code&gt;action-validator&lt;/code&gt;&lt;/a&gt;, one that I&#xA;particularly packaged in&#xA;&lt;a href=&#34;https://github.com/NixOS/nixpkgs/pull/260217&#34;&gt;nixpkgs&lt;/a&gt; to use in those cases.&#xA;But you could use e.g.: a validator of Kubernetes YAML. Or a generic YAML lint&#xA;like this &lt;a href=&#34;https://github.com/adrienverge/yamllint&#34;&gt;one&lt;/a&gt;. The possibilities are&#xA;endless.&lt;/p&gt;&#xA;&lt;p&gt;Let&#39;s modify our &lt;code&gt;flake.nix&lt;/code&gt; to add the validation:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  # ...&#xA;  outputs = { nixpkgs, ... }:&#xA;    {&#xA;      packages.x86_64-linux =&#xA;        let&#xA;          inherit (nixpkgs) lib;&#xA;          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };&#xA;        in&#xA;        {&#xA;          toYAML = pkgs.runCommand &amp;quot;toYAML&amp;quot; {&#xA;            buildInputs = with pkgs; [ action-validator yj ];&#xA;            json = builtins.toJSON (import ./go.nix);&#xA;            passAsFile = [ &amp;quot;json&amp;quot; ];&#xA;          } &#39;&#39;&#xA;            mkdir -p $out&#xA;            yj -jy &amp;lt; &amp;quot;$jsonPath&amp;quot; &amp;gt; $out/go.yaml&#xA;            action-validator -v $out/go.yaml&#xA;          &#39;&#39;;&#xA;        };&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And let&#39;s add an error in our &lt;code&gt;go.nix&lt;/code&gt; file:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/go.nix b/go.nix&#xA;index 25e0596..8c00033 100644&#xA;--- a/go.nix&#xA;+++ b/go.nix&#xA;@@ -5,7 +5,7 @@&#xA;   jobs = {&#xA;     build = {&#xA;       runs-on = &amp;quot;ubuntu-latest&amp;quot;;&#xA;-      permissions.contents = &amp;quot;write&amp;quot;;&#xA;+      permissions.contents = [ &amp;quot;write&amp;quot; ];&#xA;       steps = [&#xA;         { uses = &amp;quot;actions/checkout@v4&amp;quot;; }&#xA;         {&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Finally, let&#39;s try to build our YAML file again:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ nix build .#packages.x86_64-linux.toYAML&#xA;error: builder for &#39;/nix/store/j8wr6j1pvyf986sf74hqw8k31lvlzac5-toYAML.drv&#39; failed with exit code 1;&#xA;       last 25 log lines:&#xA;       &amp;gt;                                 &amp;quot;Additional property &#39;runs-on&#39; is not allowed&amp;quot;,&#xA;       &amp;gt;                             ),&#xA;       &amp;gt;                             path: &amp;quot;/jobs/build&amp;quot;,&#xA;       &amp;gt;                             title: &amp;quot;Property conditions are not met&amp;quot;,&#xA;       &amp;gt;                         },&#xA;       &amp;gt;                         Properties {&#xA;       &amp;gt;                             code: &amp;quot;properties&amp;quot;,&#xA;       &amp;gt;                             detail: Some(&#xA;       &amp;gt;                                 &amp;quot;Additional property &#39;steps&#39; is not allowed&amp;quot;,&#xA;       &amp;gt;                             ),&#xA;       &amp;gt;                             path: &amp;quot;/jobs/build&amp;quot;,&#xA;       &amp;gt;                             title: &amp;quot;Property conditions are not met&amp;quot;,&#xA;       &amp;gt;                         },&#xA;       &amp;gt;                         Required {&#xA;       &amp;gt;                             code: &amp;quot;required&amp;quot;,&#xA;       &amp;gt;                             detail: None,&#xA;       &amp;gt;                             path: &amp;quot;/jobs/build/uses&amp;quot;,&#xA;       &amp;gt;                             title: &amp;quot;This property is required&amp;quot;,&#xA;       &amp;gt;                         },&#xA;       &amp;gt;                     ],&#xA;       &amp;gt;                 },&#xA;       &amp;gt;             ],&#xA;       &amp;gt;         },&#xA;       &amp;gt;     ],&#xA;       &amp;gt; }&#xA;       For full logs, run &#39;nix log /nix/store/j8wr6j1pvyf986sf74hqw8k31lvlzac5-toYAML.drv&#39;.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Yes, the output of &lt;code&gt;action-validator&lt;/code&gt; is awfully verbose, but it is still&#xA;better than making &lt;a href=&#34;https://x.com/eric_sink/status/1430954572848287744&#34;&gt;&amp;quot;8 commits/push in one&#xA;hour&amp;quot;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If you are interested in how a more advantage usage of this technique is,&#xA;including usage of functions and constants to share common steps between&#xA;different actions, please take a look at the&#xA;&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/tree/master/actions&#34;&gt;actions&lt;/a&gt;&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/tree/fbbc8f935cc7f774f691196e1612bbf7dd2054b5/actions&#34;&gt;permalink&lt;/a&gt;)&#xA;in my &lt;code&gt;nix-config&lt;/code&gt; repository.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-31/01-generating-yaml-files-with-nix.md</guid>
      <pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>First impressions: FPGBC</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-30/01-first-impressions-fpgbc.md</link>
      <description>&lt;p&gt;Here is something for nostalgia: I just put together a &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_Boy_Color&#34;&gt;Game Boy&#xA;Color&lt;/a&gt; made of completely new&#xA;parts for a friend: here is the&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;FPGBC&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;em&gt;FP&lt;/em&gt; part of the name comes from&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Field-programmable_gate_array&#34;&gt;FPGA&lt;/a&gt;, because&#xA;instead of software emulation this device use FPGA to reproduce the device.&#xA;While I am not convinced that FPGA is necessary more accurate than a good&#xA;software emulator, one advantage of FPGA is the (possible) lower input latency&#xA;thanks to the avoidance of complexity to handle the user input (e.g.: the&#xA;Operational System). A quick playthrough against &lt;a href=&#34;https://en.wikipedia.org/wiki/Motocross_Maniacs&#34;&gt;Motocross&#xA;Maniacs&lt;/a&gt; seems to be fine, but&#xA;I can&#39;t see much difference from my &lt;a href=&#34;https://retrogamecorps.com/2022/05/15/miyoo-mini-v2-guide/&#34;&gt;Miyoo&#xA;Mini+&lt;/a&gt; (I will do&#xA;more comparisons between the two devices later), that is a software emulation&#xA;device.&lt;/p&gt;&#xA;&lt;p&gt;But I think focusing in accuracy is wrong, the main reason of getting a device&#xA;like this one is for nostalgia, and this definitely hit the mark. The quality&#xA;of the case is as good as I remember the original, and most of the details are&#xA;replicate perfectly, including reproduction stickers in the back of the device.&#xA;The only differences that I can find is the usage of USB-C port for charging in&#xA;place of the barrel jack power adapter (thanks!), and the fact that the screen&#xA;bezels are smaller compared to the original (because the screen is bigger) and&#xA;doesn&#39;t include the Game Boy Color logo (that is fine in my opinion, since it&#xA;would look weird in the fine bezels). It even has a supposedly working &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_Link_Cable&#34;&gt;Link&#xA;Cable&lt;/a&gt; (I don&#39;t have another&#xA;Game Boy to test). Sadly it is missing the infrared sensor, but the usage of&#xA;that was pretty limited anyway.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/thiagokokada/blog/raw/main/2024-07-30/PXL_20240729_175245569.jpg&#34; alt=&#34;FPGBC running Tetris.&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/thiagokokada/blog/raw/main/2024-07-30/PXL_20240729_175131157.jpg&#34; alt=&#34;Back of FPGBC. It includes even reproduction stickers of the original.&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;So how well does it work? I can&#39;t say for sure. I don&#39;t have any original games&#xA;with me, so I am relying in backups and a&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Flashcard&#34;&gt;flashcard&lt;/a&gt; for now. Many games that I&#xA;tested works fine, a few of them have graphical issues that can be fixed in the&#xA;menu (more about it later), and some of them doesn&#39;t boot. But I don&#39;t know if&#xA;the issue with the games not booting are because of the roms, the flashcard or&#xA;the device itself.&lt;/p&gt;&#xA;&lt;p&gt;By the way, the flashcard I am using is a cheap knockoff of an &lt;a href=&#34;https://gbatemp.net/review/everdrive-gb.141/&#34;&gt;Everdrive&#xA;GB&lt;/a&gt;. This FPGBC came with&#xA;firmware v1.09, while there is an update available for v1.10 in the&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;website&lt;/a&gt;. I had an weird issue in&#xA;the new firmware where no games would boot with this knockoff Everdrive so I&#xA;had to go back to v1.09, but again, I am not sure if the issue was fact that I&#xA;am using a knockoff device or this would happen with an original Everdrive GB.&#xA;If you are going to buy a proper Everdrive, you probably wouldn&#39;t get a&#xA;Everdrive GB anyway since it is discontinued, and it seems the &lt;a href=&#34;https://www.reddit.com/r/Gameboy/comments/1atwjh3/fpgbc_everdrive_compatibility/&#34;&gt;newer&#xA;versions&lt;/a&gt;&#xA;have better compatibility with FPGBC.&lt;/p&gt;&#xA;&lt;p&gt;Sadly that the update didn&#39;t work, since there is this&#xA;&lt;a href=&#34;https://github.com/makhowastaken/GWGBC_FW&#34;&gt;repository&lt;/a&gt; that patches the&#xA;firmware to boot the original logo instead of the ugly FPGBC one. And yes, for&#xA;some reason the v1.09 firmware from this repository still doesn&#39;t work with my&#xA;knockoff Everdrive.&lt;/p&gt;&#xA;&lt;p&gt;By the way, it seems the device is not easy to brick: I borked the firmware&#xA;update process once while trying to downgrade back to v1.09, resulting in a&#xA;black screen when I turned on the console. But just connecting the device to&#xA;the computer and powering on, I could flash the firmware again and the device&#xA;came back to life.&lt;/p&gt;&#xA;&lt;p&gt;About the features of the device: if you press the volume button (yes, you can&#xA;press it now), it opens the following menu:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/thiagokokada/blog/raw/main/2024-07-30/PXL_20240729_210604830.jpg&#34; alt=&#34;FPGBC menu.&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;The first 2 features are the LCD backlight and volume. I didn&#39;t talk about&#xA;those, but the LCD screen seems to be IPS, and the quality is really good, and&#xA;also looks bright enough to play even under bad lightining conditions. And the&#xA;speaker has good quality, the sound is better than I remember, but sadly the&#xA;maximum volume is kind low. Still should be enough for playing in a quiet room.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;DISPMOD&lt;/code&gt; is probably the most controversial option: it allow you to set which&#xA;scale you want. Anything with &lt;code&gt;EMU&lt;/code&gt; at the end means emulating the original&#xA;colors, and as far I remember it gets really close. You can also chose betwen&#xA;&lt;code&gt;X4&lt;/code&gt;, &lt;code&gt;X4P&lt;/code&gt; and &lt;code&gt;FUL&lt;/code&gt;, the last one is the one shown in the photos where the&#xA;image fills the whole screen at the cost of non-integer scaling. &lt;code&gt;X4&lt;/code&gt; is&#xA;integer scaling, however the image doesn&#39;t fill the whole screen. The &lt;code&gt;X4P&lt;/code&gt;&#xA;also includes a pixel effect that makes the image closer than the original&#xA;screen. It actually looks good, but the fact that I chose a white border for&#xA;this FPGBC makes the border really distracting. Maybe the black one is a better&#xA;choice if you want integer scale.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;CORE&lt;/code&gt; is simple: you can choose between &lt;code&gt;GB&lt;/code&gt; (Game Boy) or &lt;code&gt;GBC&lt;/code&gt; (Game Boy&#xA;Color). For those who don&#39;t know, you can run Game Boy games in Game Boy Color&#xA;and they will be automatically colorised. Some people don&#39;t like this and&#xA;prefer the colors of &lt;code&gt;GB&lt;/code&gt;, so you have this option. The &lt;code&gt;GB_PALETTE&lt;/code&gt; allows you&#xA;to chose the color in GB mode, for example, the green-ish colors from the&#xA;original Game Boy or the blue-ish colors from &lt;a href=&#34;https://nintendo.fandom.com/wiki/Game_Boy_Light&#34;&gt;Game Boy&#xA;Light&lt;/a&gt;. And yes, you can&#xA;choose the color palette for Game Boy games running in &lt;code&gt;GBC&lt;/code&gt; mode by pressing a&#xA;&lt;a href=&#34;https://gbstudiocentral.com/tips/game-boy-color-modes/&#34;&gt;button combination&lt;/a&gt; at&#xA;the boot screen, but it seems not working in my unit and again, not sure if the&#xA;fault is my knockoff Everdrive.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;FRAME_MIX&lt;/code&gt; basically is an option that makes some effects, like transparency&#xA;in &lt;a href=&#34;https://en.wikipedia.org/wiki/Wave_Race&#34;&gt;Wave Race&lt;/a&gt;, to work at the cost of&#xA;introducing blurriness. The reason for this is that those effects depends in&#xA;the fact that the Game Boy screen was slow refresh, so you could rely on it by&#xA;rapidly changing pixels to create some interesting effects, but sadly those&#xA;effects doesn&#39;t work well in modern displays.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;GB_CLRFIX&lt;/code&gt; is the option I mentioned before, where some Game Boy games just&#xA;get completely wrong colors for some reason, e.g.: &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Addams_Family_(video_game)&#34;&gt;The Addams&#xA;Family&lt;/a&gt;. Turning&#xA;on fixes those games, but I am not sure if this option breaks other games.&lt;/p&gt;&#xA;&lt;p&gt;Finally, &lt;code&gt;SPD&lt;/code&gt; allows you to increase or decrease the CPU clock, slowing or&#xA;speeding up the games (including the sound). The result can be hilarious, so I&#xA;think this is a nice addition to the features. Sadly you can&#39;t know what the&#xA;default speed is, so you need to rely on sound to adjust back to the default.&lt;/p&gt;&#xA;&lt;p&gt;So in the end, can I recommend a FPGBC? I am not sure. If you want a device to&#xA;play games, I still think something like a Miyoo Mini+ is a better choice. Not&#xA;only you will have access to more games from different platforms, you also&#xA;don&#39;t need to rely on flashcards or cartridges. Also it has way more features&#xA;than FPGBC, like wireless multiplayer,&#xA;&lt;a href=&#34;https://retroachievements.org/&#34;&gt;RetroArchivements&lt;/a&gt; and save states.&lt;/p&gt;&#xA;&lt;p&gt;But the actual reason to get a FPGBC is nostalgia, and for that I think the&#xA;FPGBC is difficult to beat. The price of the &lt;a href=&#34;https://funnyplaying.com/products/fpgbc-kit&#34;&gt;kit to&#xA;assemble&lt;/a&gt; ($69.90) is cheaper than&#xA;most Game Boy&#39;s in good condition you can find in eBay, and you get for that&#xA;price a rechargable battery, an amazing quality screen, the PCB and the&#xA;speaker. You need to buy separately the case and the buttons, but in total you&#xA;will still end up paying less, and allows you to fully customise your build.&#xA;And the result device is not only in mint condition, it is really convenient&#xA;too: recharging batteries (via USB-C even) is much more convenient than buying&#xA;AA batteries, and the screen not only is better but it even has backlight. You&#xA;can also a fully built console for&#xA;&lt;a href=&#34;https://funnyplaying.com/products/fpgbc-console&#34;&gt;$99.00&lt;/a&gt;, but you have less&#xA;options of customisation.&lt;/p&gt;&#xA;&lt;p&gt;This is the classic case of do what I say, don&#39;t do what I do. This FPGBC is a&#xA;gift, and I will buy another one soon. Can&#39;t wait to play &lt;a href=&#34;https://en.wikipedia.org/wiki/Pok%C3%A9mon_Gold_and_Silver&#34;&gt;Pokémon&#xA;Gold&lt;/a&gt; in (almost)&#xA;original hardware again.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/thiagokokada/blog/raw/main/2024-07-30/PXL_20240729_123847458.jpg&#34; alt=&#34;The kit before assemble.&#34;&gt;&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-30/01-first-impressions-fpgbc.md</guid>
      <pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Go, a reasonable good language</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-29/02-go-a-reasonable-good-language.md</link>
      <description>&lt;p&gt;Go was one of the languages that I always was interested to learn, but never&#xA;got the hang of it. I first got interested in the language when I was in my&#xA;first job, between 2016-2018. At the time the language was a completely&#xA;different beast: no modules, no generics, no easy way to error wrap yet, etc.&lt;/p&gt;&#xA;&lt;p&gt;Go forward 2023 (no pun indented), I wrote my &lt;a href=&#34;https://github.com/thiagokokada/twenty-twenty-twenty/&#34;&gt;first project in&#xA;Go&lt;/a&gt;, wrote some scripts&#xA;at &lt;code&gt;$CURRENT_JOB&lt;/code&gt; in the language, and now wrote &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/&#34;&gt;my first&#xA;library&lt;/a&gt; (with an &lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md&#34;&gt;interesting&#xA;way to run CI&lt;/a&gt;.&#xA;I am also writing more&#xA;&lt;a href=&#34;https://github.com/thiagokokada/nix-configs/blob/8c559527ed12e1d4f57a3fc5c72630b956f4c290/home-manager/desktop/wayland/hyprland/hyprtabs/hyprtabs.go&#34;&gt;scripts&lt;/a&gt;&#xA;in the language, where I would prefer to use Bash or Python before. Heck, even&#xA;this blog is automatically published with a &lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/2024-07-29/01-quick-bits-why-you-should-automate-everything.md&#34;&gt;Go&#xA;script&lt;/a&gt;, that&#xA;used to be a &lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md&#34;&gt;Python&#xA;one&lt;/a&gt; before. I can say&#xA;that nowadays it is another language in my toolbox, and while it is still a&#xA;love and hate relationship, recently it is more about love and less about hate.&lt;/p&gt;&#xA;&lt;p&gt;The points that I love about Go is probably obvious for some, but still&#xA;interesting to talk about anyway. The fact that the language generates static&#xA;binaries by default and have fast compilation times is something that I&#xA;apreciate since I first heard about the language, and now that I am using the&#xA;language frequently are points I appreciate even more. Something about getting&#xA;almost instant feedback after changing a line of code and running &lt;code&gt;go run&lt;/code&gt;&#xA;(even with its quirks) are great for the developer experience. This is the main&#xA;reason why I am using the language more frequently for scripts.&lt;/p&gt;&#xA;&lt;p&gt;Then we have the fast startup times. I am kind of sensitive to latency,&#xA;especially of command line utilities that need to answer fast when I expect&#xA;them to be fast (e.g.: &lt;code&gt;foo --help&lt;/code&gt;). This is one part where I could have&#xA;issues in Python, especially for more complex programs, but in Go it is rarely&#xA;an issue.&lt;/p&gt;&#xA;&lt;p&gt;Modules are also fantastic. It is not without its weirdness (like everything in&#xA;Go ecossystem), but the fact that it is so easy to add and manage dependencies&#xA;in a project using only the &lt;code&gt;go&lt;/code&gt; CLI is great. I also like that it generates a&#xA;hash of every dependency, make it reproducible (well, probably not at Nix&#xA;level, but still reproducible).&lt;/p&gt;&#xA;&lt;p&gt;Since I started to talk about &lt;code&gt;go&lt;/code&gt; CLI, what a great tool! The fact that you&#xA;can manage dependencies, generate documentation, format code, lint, run&#xA;tests/&lt;a href=&#34;https://blog.logrocket.com/benchmarking-golang-improve-function-performance/&#34;&gt;benchmarks&lt;/a&gt;/&lt;a href=&#34;https://go.dev/doc/security/fuzz/&#34;&gt;fuzzing&lt;/a&gt;,&#xA;check code for &lt;a href=&#34;https://go.dev/doc/articles/race_detector&#34;&gt;races&lt;/a&gt; etc., all&#xA;with just the &amp;quot;compiler&amp;quot; for the language is excelent. Still probably one of&#xA;the best developer experiences I know in any programming language (maybe only&#xA;rivaled by &lt;a href=&#34;https://ziglang.org/&#34;&gt;Zig&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;I will not even talk about the things that everyone talks about Go, like&#xA;&lt;a href=&#34;https://go.dev/doc/effective_go#goroutines&#34;&gt;goroutines&lt;/a&gt;, because I just don&#39;t&#xA;think I can add anything interesting to the topic.&lt;/p&gt;&#xA;&lt;p&gt;Now for the parts that I like less, the test part still quirks me that it is&#xA;not based in assertions, but thankfully it is easy to write assertions with&#xA;generics nowadays:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Equal[T comparable](t *testing.T, got, want T) {&#xA;&#x9;t.Helper()&#xA;&#x9;if got != want {&#xA;&#x9;&#x9;t.Errorf(&amp;quot;got: %#v, want: %#v&amp;quot;, got, want)&#xA;&#x9;}&#xA;}&#xA;&#xA;func GreaterOrEqual[T cmp.Ordered](t *testing.T, actual, expected T) {&#xA;&#x9;t.Helper()&#xA;&#x9;if actual &amp;lt; expected {&#xA;&#x9;&#x9;t.Errorf(&amp;quot;got: %v; want: &amp;gt;=%v&amp;quot;, actual, expected)&#xA;&#x9;}&#xA;}&#xA;&#xA;// etc...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Just one of those things that I end up re-writing in every project. Yes, I know&#xA;about &lt;a href=&#34;https://github.com/stretchr/testify&#34;&gt;testify&lt;/a&gt; and other assertion&#xA;libraries, but quoting &lt;a href=&#34;https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;amp;t=568s&#34;&gt;Rob&#xA;Pike&lt;/a&gt; here, &amp;quot;a little&#xA;copying is better than a little dependency&amp;quot;. As long the code you write is&#xA;trivial, it is better to duplicate the code than try to import a dependency.&lt;/p&gt;&#xA;&lt;p&gt;About another piece of code that generics allows me to write and I always end&#xA;up re-writing in every project is the &lt;code&gt;must*&lt;/code&gt; family of functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func must(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func must1[T any](v T, err error) T {&#xA;&#x9;must(err)&#xA;&#x9;return v&#xA;}&#xA;&#xA;func must2[T1 any, T2 any](v1 T1, v2 T2, err error) T {&#xA;&#x9;must(err)&#xA;&#x9;return v1, v2&#xA;}&#xA;&#xA;// must3, must4, etc...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Those functions are so useful, especially for scripts where I generally don&#39;t&#xA;want to handle each error: if I have an error, I want the program to halt and&#xA;print a stack trace (exactly as I would have with a language with exceptions).&#xA;It basically allow me to convert code from:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;contents, err := os.ReadFile(&amp;quot;file&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;contents := must1(os.ReadFile(&amp;quot;file&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This brings Go closer to Python to me, and I think for scripts this is&#xA;something great.&lt;/p&gt;&#xA;&lt;p&gt;Finally, for the things that I hate, well the biggest one currently is the lack&#xA;of nullability (or in Go terms,&#xA;&lt;a href=&#34;https://github.com/golang/go/issues/49202&#34;&gt;nillability&lt;/a&gt;). After using&#xA;languages that has it, like Kotlin, or even something like&#xA;&lt;a href=&#34;https://www.mypy-lang.org/&#34;&gt;mypy&lt;/a&gt;, this is one of those things that completely&#xA;changes the developer experience. I also still don&#39;t like the error handling&#xA;(but &lt;code&gt;must*&lt;/code&gt; goes far by improving the situation, when it is possible to use&#xA;it), especially because it is easy to lose context on it:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// bad&#xA;func readFileContents(file) ([]byte, error) {&#xA;    contents, err := os.ReadFile(file)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return contents, nil&#xA;}&#xA;&#xA;// good&#xA;func readFileContents(file) ([]byte, error) {&#xA;    contents, err := os.ReadFile(file)&#xA;    if err != nil {&#xA;        return nil, fmt.Errorf(&amp;quot;readFileContents: error while reading a file: %w&amp;quot;, err)&#xA;    }&#xA;    return contents, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I also have some grips about the mutate everything approach of the language. I&#xA;prefer immutability by default, but I find that in general as long as you split&#xA;your functions at a reasonable size it is generally fine.&lt;/p&gt;&#xA;&lt;p&gt;And for a language that is supposed to be straightforward, it is strange on how&#xA;much magic the language relies on, in the form of things like &lt;a href=&#34;https://go.dev/doc/modules/layout&#34;&gt;&lt;code&gt;internal&lt;/code&gt; and&#xA;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; packages, name capitalisation to&#xA;indicate visibility (&lt;code&gt;private&lt;/code&gt; vs &lt;code&gt;Public&lt;/code&gt;), conditional compiling by filenames&#xA;(e.g.: &lt;code&gt;foo_amd64.go&lt;/code&gt;, &lt;code&gt;bar_linux.go&lt;/code&gt;), magic comments (e.g.: &lt;code&gt;//go:build&lt;/code&gt;),&#xA;etc.&lt;/p&gt;&#xA;&lt;p&gt;I expect to write more Go code going forward. Not because it is the perfect&#xA;language or whatever, but just because it a is language that has some really&#xA;good qualities that makes the language attractive even with the issues that I&#xA;have. That makes it a reasonable good language, and at least for me this is&#xA;good enough.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-29/02-go-a-reasonable-good-language.md</guid>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Quick bits: why you should automate everything</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-29/01-quick-bits-why-you-should-automate-everything.md</link>
      <description>&lt;p&gt;If everything works as expected this blog post should appear in &lt;a href=&#34;https://kokada.capivaras.dev/&#34;&gt;in my&#xA;blog&lt;/a&gt; without I ever touching the&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; website. I rewrote my &lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md&#34;&gt;previous Python&#xA;script&lt;/a&gt; to Go&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/3c39e0f7cd58b1af885f69871490b05bf6fc7d99/blog.go&#34;&gt;permalink&lt;/a&gt;)&#xA;since my attempt to generate proper description to the RSS feed resulted in&#xA;slow startup times (not because of Python, but because of my usage of&#xA;&lt;code&gt;nix-shell&lt;/code&gt; since I didn&#39;t want to deal with&#xA;&lt;a href=&#34;https://docs.python.org/3/library/venv.html&#34;&gt;venv&lt;/a&gt; or anything to manage my&#xA;Python dependencies).&lt;/p&gt;&#xA;&lt;p&gt;My previous workflow of this blog already involved me writing the texts in&#xA;&lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt;, copying and pasting the result in the&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; website and publishing. This was not&#xA;that bad, except that it seems I have a heavy tendency of editing my posts&#xA;multiple times. Copying and pasting data between neovim and the website became&#xA;tedious, so I decided to give up and automate the whole process.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mataroa.blog/&#34;&gt;Mataroa&lt;/a&gt; (the blog platform&#xA;&lt;a href=&#34;https://capivavas.dev&#34;&gt;capivaras.dev&lt;/a&gt; run) has a reasonable good&#xA;&lt;a href=&#34;https://mataroa.blog/api/docs/&#34;&gt;API&lt;/a&gt;, and it only took a few hours to get a&#xA;version of publishing working (it would take less if&#xA;&lt;a href=&#34;https://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt;, the framework Mataroa is written, did&#xA;not have a weird behavior with URLs missing a trailing &lt;code&gt;/&lt;/code&gt;). An additional few&#xA;lines of&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/51b20612335c7f4312a51a0f436235b4b701ce8b/.github/workflows/go.yml&#34;&gt;YAML&lt;/a&gt;&#xA;to make GitHub Actions trigger a pipeline and now I should never have to&#xA;manually update my blog again.&lt;/p&gt;&#xA;&lt;p&gt;I could have not done this. I mean, I probably wasted more time writing an&#xA;automation than I actually wasted publishing manually. But the manual process&#xA;is easy to miss, and I already did multiple mistakes publishing in the manual&#xA;method. For example, when writing the Markdown files, each post is written in a&#xA;particular format, where the first header is considered the title, so I need to&#xA;remove it from the contents during publication. But of course, this is easy to&#xA;miss, and I had to fix this multiple times already.&lt;/p&gt;&#xA;&lt;p&gt;So yes, I think this is a good lesson on why you should automate everything. It&#xA;is more than just about &lt;a href=&#34;https://xkcd.com/1205/&#34;&gt;time savings&lt;/a&gt;, it is about&#xA;reducing mistakes and even documenting (even if poorly) a process. I mean, the&#xA;code I wrote is not that great, but I can definitely rely on it in the future&#xA;to remember what I need to do. It will be much faster than trying to learn from&#xA;scratch again.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-29/01-quick-bits-why-you-should-automate-everything.md</guid>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Quick bits: nix-shell is cursed</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</link>
      <description>&lt;p&gt;The other day I had to run a PHP project in my machine. I have no idea how PHP&#xA;ecosystem work, I just wanted to get it to run.&lt;/p&gt;&#xA;&lt;p&gt;The easiest way to get a script to run if you use Nix is to use &lt;code&gt;nix-shell&lt;/code&gt;. As&#xA;many of you probably know, you can add &lt;code&gt;nix-shell&lt;/code&gt; as a shebang in your scripts&#xA;to run them as &lt;code&gt;./script&lt;/code&gt;. This was a PHP script so I wanted to do the same.&#xA;Easy right?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;#!nix-shell -i php -p php83&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Fatal error: strict_types declaration must be the very first statement in the script in index.php on line 4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So it seems that &lt;code&gt;declare(strict_types=1)&lt;/code&gt; needs to be the first line in a PHP&#xA;script if used. I removed &lt;code&gt;declare(strict_types=1)&lt;/code&gt; and while the script works,&#xA;I don&#39;t have enough expertise in PHP to know if this would be safe or not.&lt;/p&gt;&#xA;&lt;p&gt;I decided to try something that initially looked really dumb:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#!/use/bin/env nix-shell&#xA;&amp;lt;?php&#xA;declare(strict_types=1);&#xA;#!nix-shell -i php -p php83&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./index.php&#xA;Works&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Wat? I mean, it is not dumb if it works, but this at least looks cursed.&lt;/p&gt;&#xA;&lt;p&gt;Eventually I found this&#xA;&lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446220517&#34;&gt;comment&lt;/a&gt; in a&#xA;Nix issue talking about cases where &lt;code&gt;nix-shell&lt;/code&gt; shebang doesn&#39;t work. It looks&#xA;like the classic case of a &lt;a href=&#34;https://github.com/NixOS/nix/issues/2570#issuecomment-446222206&#34;&gt;bug that becomes a&#xA;feature&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Update: after posting this in&#xA;&lt;a href=&#34;https://lobste.rs/s/gkcgza/quick_bits_nix_shell_is_cursed&#34;&gt;Lobte.rs&lt;/a&gt;, it seems&#xA;someone decided to open a &lt;a href=&#34;https://github.com/NixOS/nix/pull/11202&#34;&gt;Pull&#xA;Request&lt;/a&gt; to document this behavior.&#xA;Also the equivalent for the new &lt;a href=&#34;https://nix.dev/manual/nix/2.23/command-ref/new-cli/nix#shebang-interpreter&#34;&gt;nix&#xA;CLI&lt;/a&gt;&#xA;explicitly documents this behavior:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Note that the &lt;code&gt;#! nix&lt;/code&gt; lines don&#39;t need to follow after the first line, to&#xA;accomodate other interpreters.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-27/01-quick-bits-nix-shell-is-cursed.md</guid>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Using GitHub as a (bad) blog platform</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</link>
      <description>&lt;p&gt;I finally started a new blog, thanks to the offer of&#xA;&lt;a href=&#34;https://gluer.org/&#34;&gt;@ratsclub&lt;/a&gt; to give me free access to&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;. But considering how small this blog&#xA;platform is supposed to be, I want to have at least somewhere to have a backup&#xA;of my posts. I know &lt;a href=&#34;https://mataroa.blog/&#34;&gt;Mataroa&lt;/a&gt;, the blog platform that&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt; runs, has automatic e-mail backups, but&#xA;I want something more reliable.&lt;/p&gt;&#xA;&lt;p&gt;I am writing all my posts in Markdown (the format that &lt;a href=&#34;https://1.mataroa.blog/guides/markdown/&#34;&gt;Mataroa&#xA;supports&lt;/a&gt;) files inside&#xA;&lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt; anyway, so why not store all my Markdown files in&#xA;Git? So this is what I did, I now have an unofficial mirror in&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;While I am here, why not overcomplicate? Can I make an usable blog platform&#xA;from GitHub? And by that I don&#39;t mean GitHub pages, the repository itself. I&#xA;mean, it already renders Markdown files by default, so no need to do anything&#xA;in that space. To reach feature parity with&#xA;&lt;a href=&#34;https://capivaras.dev/&#34;&gt;capivaras.dev&lt;/a&gt;, I only need to have an index and RSS&#xA;(since comments are not supported anyway). No need for newsletter since GitHub&#xA;has a &lt;a href=&#34;https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/managing-subscriptions-for-activity-on-github/viewing-your-subscriptions&#34;&gt;watch&#xA;feature&lt;/a&gt;&#xA;already.&lt;/p&gt;&#xA;&lt;p&gt;After a couple of hours hacking a Python script, you can see the result of this&#xA;monstrosity &lt;a href=&#34;https://github.com/thiagokokada/blog&#34;&gt;here&lt;/a&gt;. The script, called&#xA;&lt;code&gt;gen_blog.py&lt;/code&gt;, is available at the same repository (here is a&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/c8986d1ab1b94c0986fd814629bb8eb4034fb6e7/gen_blog.py&#34;&gt;permalink&lt;/a&gt;).&#xA;It automatically generates an index at&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/main/README.md&#34;&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; with&#xA;each blog post and a&#xA;&lt;a href=&#34;https://raw.githubusercontent.com/thiagokokada/blog/main/rss.xml&#34;&gt;&lt;code&gt;rss.xml&lt;/code&gt;&lt;/a&gt;&#xA;file at the root of the repository.&lt;/p&gt;&#xA;&lt;p&gt;Instead of trying to explain the code, I am going to explain the general idea,&#xA;because I think that if you want to replicate this idea it is better to rewrite&#xA;it in a way that you understand. It shouldn&#39;t take more than 2 hours in any&#xA;decent programming language. But if you really want, the script itself is&#xA;licensed in &lt;a href=&#34;https://en.wikipedia.org/wiki/WTFPL&#34;&gt;WTFPL&lt;/a&gt; license. The code only&#xA;uses Python 3&#39;s standard library and should work in any relatively recent&#xA;version (anything newer than 3.9 should work).&lt;/p&gt;&#xA;&lt;p&gt;So the idea is basically to organise the repository and the Markdown files in a&#xA;easy way that makes it trivial to parse in a deterministic way. For example, my&#xA;repository is organised in the following way:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root&#xA;├── 2024-07-26&#xA;│   ├── 01-writing-nixos-tests-for-fun-and-profit.md&#xA;│   └── 02-using-github-as-a-bad-blog-platform.md &amp;lt;- this file&#xA;├── gen_blog.py&#xA;├── README.md&#xA;└── rss.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Each day that you write a new blog post will be on its own directory. This is&#xA;nice because Markdown files may include extra files than the posts themselves,&#xA;e.g.: images, and this organisation make it trivial to organise everything.&lt;/p&gt;&#xA;&lt;p&gt;Each post has its own Markdown file. I put a two digit number before each post,&#xA;to ensure that when publishing multiple posts at the same day I keep them in&#xA;the same order of publishing. But if you don&#39;t care about it, you can just name&#xA;the files whatever you want.&lt;/p&gt;&#xA;&lt;p&gt;Also, I am assuming that each Markdown file has a header starting with &lt;code&gt;# &lt;/code&gt;,&#xA;and that is the title of the blog post.&lt;/p&gt;&#xA;&lt;p&gt;Using the above organisation, I have this function that scrapes the repository&#xA;and collect the necessary information to generate the index and RSS files:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def grab_posts(pwd: Path):&#xA;    posts = defaultdict(list)&#xA;&#xA;    for dir in sorted(pwd.iterdir(), reverse=True):&#xA;        # Ignore non-directories or hidden files&#xA;        if not dir.is_dir() or dir.name[0] == &amp;quot;.&amp;quot;:&#xA;            continue&#xA;&#xA;        # Try to parse date from directory name&#xA;        try:&#xA;            date = datetime.strptime(dir.name, &amp;quot;%Y-%m-%d&amp;quot;)&#xA;        except ValueError:&#xA;            print(f&amp;quot;WARN: ignoring non-date directory: {dir}&amp;quot;, file=sys.stderr)&#xA;            continue&#xA;&#xA;        # Iterate between the files in the date directory&#xA;        for post in sorted(dir.iterdir(), reverse=True):&#xA;            # Ignore non-markdown files or hidden files (draft)&#xA;            if not post.suffix == &amp;quot;.md&amp;quot; or post.name[0] == &amp;quot;.&amp;quot;:&#xA;                continue&#xA;&#xA;            # Grab the first H1 section to parse as title&#xA;            text = post.read_text()&#xA;            mTitle = re.match(r&amp;quot;# (?P&amp;lt;title&amp;gt;.*)\r?\n&amp;quot;, text)&#xA;            if mTitle and (title := mTitle.groupdict().get(&amp;quot;title&amp;quot;)):&#xA;                posts[date].append({&amp;quot;title&amp;quot;: title, &amp;quot;file&amp;quot;: str(post)})&#xA;            else:&#xA;                print(f&amp;quot;WARN: did not find title for file: {post}&amp;quot;, file=sys.stderr)&#xA;&#xA;    return posts&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Some interesting tidbits: if a Markdown file has a &lt;code&gt;.&lt;/code&gt; at the start I assume it&#xA;is a draft post, and ignore it from my scraper. I added a bunch of &lt;code&gt;WARN&lt;/code&gt;&#xA;prints to make sure that the me in the future doesn&#39;t do anything dumb. Also,&#xA;sorting in reverse since reverse chronological order is the one most people&#xA;expect in blogs (i.e.: more recent blog posts at top).&lt;/p&gt;&#xA;&lt;p&gt;After running the function above, I have a resulting dictionary that I can use&#xA;to generate either a &lt;code&gt;README.md&lt;/code&gt; file or Markdown:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen_readme(posts):&#xA;    titles = []&#xA;&#xA;    for date, dayPosts in posts.items():&#xA;        for post in dayPosts:&#xA;            # This creates a relative link to the Markdown file, .e.g.:&#xA;            # ./02-using-github-as-a-bad-blog-platform.md&#xA;            link = os.path.join(&amp;quot;.&amp;quot;, post[&amp;quot;file&amp;quot;])&#xA;            # This formats the title, e.g.:&#xA;            # - [Using GitHub as a (bad) blog platform](./2024-07-26/02-using-github-as-a-bad-blog-platform.md) - 2024-07-26&#xA;            title = date.strftime(f&amp;quot;- [{post[&#39;title&#39;]}]({link}) - %Y-%m-%d&amp;quot;)&#xA;            # This appends to the list to generate the content later&#xA;            titles.append(title)&#xA;&#xA;    # README_TEMPLATE is a string with the static part of the README&#xA;    print(README_TEMPLATE.format(posts=&amp;quot;\n&amp;quot;.join(titles)))&#xA;&#xA;&#xA;def gen_rss(posts):&#xA;    # Got most of the specification from here:&#xA;    # https://www.w3schools.com/XML/xml_rss.asp&#xA;    rss = ET.Element(&amp;quot;rss&amp;quot;, version=&amp;quot;2.0&amp;quot;)&#xA;&#xA;    # Here are the RSS metadata for the blog itself&#xA;    channel = ET.SubElement(rss, &amp;quot;channel&amp;quot;)&#xA;    ET.SubElement(channel, &amp;quot;title&amp;quot;).text = &amp;quot;kokada&#39;s blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;link&amp;quot;).text = &amp;quot;https://github.com/thiagokokada/blog&amp;quot;&#xA;    ET.SubElement(channel, &amp;quot;description&amp;quot;).text = &amp;quot;dd if=/dev/urandom of=/dev/brain0&amp;quot;&#xA;&#xA;    # You create one item for each blog post&#xA;    for date, dayPost in posts.items():&#xA;        for post in dayPost:&#xA;            item = ET.SubElement(channel, &amp;quot;item&amp;quot;)&#xA;            link = urljoin(RSS_POST_LINK_PREFIX, post[&amp;quot;file&amp;quot;])&#xA;            ET.SubElement(item, &amp;quot;title&amp;quot;).text = post[&amp;quot;title&amp;quot;]&#xA;            ET.SubElement(item, &amp;quot;guid&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;link&amp;quot;).text = link&#xA;            ET.SubElement(item, &amp;quot;pubDate&amp;quot;).text = date.strftime(&#39;%a, %d %b %Y %H:%M:%S GMT&#39;)&#xA;&#xA;    # Generate the XML and indent&#xA;    tree = ET.ElementTree(rss)&#xA;    ET.indent(tree, space=&amp;quot;\t&amp;quot;, level=0)&#xA;    tree.write(&amp;quot;rss.xml&amp;quot;, xml_declaration=True, encoding=&amp;quot;UTF-8&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To publish a new Post, a basically write a Markdown file, run `./gen_readme.py&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;README.md` at the root of the repository, and see the magic happen.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;It works much better than I initially anticipated. The &lt;code&gt;README.md&lt;/code&gt; is properly&#xA;populated with the titles and links. The RSS is kind of empty since it has no&#xA;description, but it seems to work fine (at least in&#xA;&lt;a href=&#34;https://www.inoreader.com/&#34;&gt;Inoreader&lt;/a&gt;, my RSS reader of choice). I can&#xA;probably fill the post description with more information if I really want, but&#xA;it is enough for now (update: it is working now, you just need to render the&#xA;Markdown as HTML and escape the tags;&#xA;&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/9506051cc3d49f203304174b335ff62de9d17a05/gen_blog.py&#34;&gt;permalink&lt;/a&gt;&#xA;for the updated script). Not sure who is that interested in my writing that&#xA;will want to use this RSS feed instead the one available in&#xA;&lt;a href=&#34;https://kokada.capivaras.dev/rss/&#34;&gt;capivaras.dev&lt;/a&gt; anyway.&lt;/p&gt;&#xA;&lt;p&gt;Also, while I am using GitHub here, the same idea would work in GitLab, Gitea,&#xA;sr.ht or whatever. As long as your source hub supports Markdown files it should&#xA;work.&lt;/p&gt;&#xA;&lt;p&gt;So that is it. I am not saying this is a good idea for your primary blog&#xA;platform or whatever, and I still prefer to publish to a platform that doesn&#39;t&#xA;track users or have tons of JavaScript or whatever. But if you want a backup of&#xA;your posts and you are already writing Markdown anyway, well, there are worse&#xA;ways to do it I think.&lt;/p&gt;&#xA;&lt;p&gt;Update: I rewrote the script again using Go&#xA;(&lt;a href=&#34;https://github.com/thiagokokada/blog/blob/3ece3853e7dd32977e7ec5238d2955e530ca4beb/blog.go&#34;&gt;permalink&lt;/a&gt;).&#xA;The reason for it is because when I started rendering Markdown (for&#xA;descriptions) the Python version got quite slow (not the fault of Python&#xA;itself, mostly because of the usage of &lt;code&gt;nix-shell&lt;/code&gt; to manage dependencies;&#xA;something that Go doesn&#39;t need). Took about half an hour, showing how easy it&#xA;is to do the same.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/02-using-github-as-a-bad-blog-platform.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Writing NixOS tests for fun and profit</title>
      <link>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</link>
      <description>&lt;p&gt;I recently started a &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go&#34;&gt;new side&#xA;project&lt;/a&gt; writing an IPC library in&#xA;Go for &lt;a href=&#34;https://hyprland.org/&#34;&gt;Hyprland&lt;/a&gt;, a Window Manager for Wayland.&lt;/p&gt;&#xA;&lt;p&gt;Once I got past the Work-in-Progress phase, I realise I had an issue: I wrote&#xA;some tests, but I was running then inside my system running Hyprland. And the&#xA;tests themselves were annoying: since they send commands to the current running&#xA;Hyprland instance, I was having programs being opened and settings being&#xA;changed, because this was the only way to have a reasonable good confidence&#xA;that what I was doing was correct. So I need to do like any good developer and&#xA;implement a CI, but how?&lt;/p&gt;&#xA;&lt;p&gt;One approach would be to create something like a mock client and test against&#xA;my mock. Since this mock wouldn&#39;t need a running Hyprland instance the tests&#xA;could run everywhere (even in non-Linux systems!), but they wouldn&#39;t be much&#xA;useful. Mocks are great for testing business logic, but not really for making&#xA;sure everything is working correctly.&lt;/p&gt;&#xA;&lt;p&gt;I need something more akin to an integration test, but this is tricky. It is&#xA;not like I am doing integration with e.g.: PostgreSQL that has thousands of&#xA;libraries available to make integration tests easier, I am doing integration&#xA;with a Window Manager that is a moving target with multiple breaking changes in&#xA;each release. And this is where NixOS tests enter, a way to run tests inside&#xA;Virtual Machines configured in Nix.&lt;/p&gt;&#xA;&lt;p&gt;I am a long time NixOS user and commiter, but I never wrote a NixOS test&#xA;outside of &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;nixpkgs&lt;/a&gt; itself. However I knew&#xA;it was possible, and after doing a quick reading of the &lt;a href=&#34;https://wiki.nixos.org/wiki/NixOS_VM_tests&#34;&gt;Wiki&#xA;entry&lt;/a&gt; about it, I was ready to&#xA;start.&lt;/p&gt;&#xA;&lt;p&gt;The first part is to call &lt;code&gt;pkgs.testers.runNixOSTest&lt;/code&gt; and configure the machine&#xA;as any other NixOS system, e.g.:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ pkgs, ... }:&#xA;pkgs.testers.runNixOSTest {&#xA;  name = &amp;quot;hyprland-go&amp;quot;;&#xA;&#xA;  nodes.machine =&#xA;    { config, pkgs, lib, ... }:&#xA;    {&#xA;      # bootloader related configuration&#xA;      boot.loader.systemd-boot.enable = true;&#xA;      boot.loader.efi.canTouchEfiVariables = true;&#xA;&#xA;      # enable hyprland&#xA;      programs.hyprland.enable = true;&#xA;&#xA;      # create a user called alice&#xA;      users.users.alice = {&#xA;        isNormalUser = true;&#xA;      };&#xA;&#xA;      # add some extra packages that we need during tests&#xA;      environment.systemPackages = with pkgs; [ go kitty ];&#xA;&#xA;      # auto login as alice&#xA;      services.getty.autologinUser = &amp;quot;alice&amp;quot;;&#xA;&#xA;      # configure VM, increase memory and CPU and enable OpenGL via LLVMPipe&#xA;      virtualisation.qemu = {&#xA;        options = [&#xA;          &amp;quot;-smp 2&amp;quot;&#xA;          &amp;quot;-m 4G&amp;quot;&#xA;          &amp;quot;-vga none&amp;quot;&#xA;          &amp;quot;-device virtio-gpu-pci&amp;quot;&#xA;        ];&#xA;      };&#xA;&#xA;      # Start hyprland at login&#xA;      programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;;&#xA;    };&#xA;&#xA;  testScript = &amp;quot;start_all()&amp;quot;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A few details that I want to bring to attention. The first one is how easy it&#xA;is to setup things like a normal user account, add some extra packages we need&#xA;for testing, add Hyprland itself and configure auto-login. I have no idea how&#xA;painful it would be to automatise all those steps in e.g.: Ansible, but here we&#xA;are in a few lines of Nix code. This is, of course, thanks to all the&#xA;contributors to nixpkgs that implement something that help their own use case,&#xA;but once combined make it greater than the sum of the parts.&lt;/p&gt;&#xA;&lt;p&gt;Second is something that I took a while to figure out: how to enable GPU&#xA;acceleration inside the VM. You see, Hyprland, different from other Window&#xA;Managers, requires OpenGL support. This is basically why the flag &lt;code&gt;-device virtio-gpu-pci&lt;/code&gt; is in &lt;code&gt;virtualisation.qemu.options&lt;/code&gt;, this enables OpenGL&#xA;rendering via LLVMPipe, that while being slow since it is rendered in CPU, is&#xA;sufficient for this case.&lt;/p&gt;&#xA;&lt;p&gt;Putting the above code inside a&#xA;&lt;a href=&#34;https://wiki.nixos.org/wiki/Flakes&#34;&gt;&lt;code&gt;flake.nix&lt;/code&gt;&lt;/a&gt; for reproducibility, I had&#xA;something similar to:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  description = &amp;quot;Hyprland&#39;s IPC bindings for Go&amp;quot;;&#xA;&#xA;  inputs = {&#xA;    nixpkgs.url = &amp;quot;github:NixOS/nixpkgs/nixos-unstable&amp;quot;;&#xA;  };&#xA;&#xA;  outputs = { nixpkgs, ... }:&#xA;    {&#xA;      checks.x86_64-linux =&#xA;        let&#xA;          pkgs = import nixpkgs { system = &amp;quot;x86_64-linux&amp;quot;; };&#xA;        in&#xA;        {&#xA;          testVm = pkgs.testers.runNixOSTest {&#xA;            # the code above&#xA;          };&#xA;        }&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I can now run &lt;code&gt;nix build .#checks.x86_64-linux.testVm -L&lt;/code&gt; to build and run the&#xA;VM. However it is not really useful right now, since we didn&#39;t add any useful&#xA;code in &lt;code&gt;testScript&lt;/code&gt;, the core of the NixOS test framework. We can also run&#xA;&lt;code&gt;nix build .#checks.x86_64-linux.testVm.driverInteractive&lt;/code&gt; and&#xA;&lt;code&gt;./result/bin/nixos-test-driver&lt;/code&gt;: this will start a Python console where we can&#xA;manually play with the VM (try typing &lt;code&gt;start_all()&lt;/code&gt; for example).&lt;/p&gt;&#xA;&lt;p&gt;The &lt;code&gt;testScript&lt;/code&gt; is a sequence of Python statements that perform various&#xA;actions, such as starting VMs, executing commands in the VMs, and so on. More&#xA;about it in the official&#xA;&lt;a href=&#34;https://nixos.org/manual/nixos/stable/index.html#sec-nixos-tests&#34;&gt;documentation&lt;/a&gt;.&#xA;For our case we can start with something like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;    testScript = /* python */ &#39;&#39;&#xA;      start_all()&#xA;&#xA;      machine.wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&#xA;      machine.wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The first statement, &lt;code&gt;start_all()&lt;/code&gt;, starts all VMs, in this case we have only&#xA;one, called &lt;code&gt;machine&lt;/code&gt;. We send two further commands to &lt;code&gt;machine&lt;/code&gt;:&#xA;&lt;code&gt;wait_for_unit(&amp;quot;multi-user.target&amp;quot;)&lt;/code&gt; and&#xA;&lt;code&gt;wait_for_file(&amp;quot;/home/alice/test-finished&amp;quot;)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The first command waits until systemd&#39;s &lt;code&gt;multi-user.target&lt;/code&gt; is ready, a good&#xA;way to ensure that the system is ready for further commands. The second one we&#xA;wait for a file called &lt;code&gt;test-finished&lt;/code&gt; to appear in Alice&#39;s &lt;code&gt;$HOME&lt;/code&gt; (basically,&#xA;a canary), but how can we generate this file?&lt;/p&gt;&#xA;&lt;p&gt;Remember that we added &lt;code&gt;programs.bash.loginShellInit = &amp;quot;Hyprland&amp;quot;&lt;/code&gt;, that&#xA;automatically starts Hyprland when Alice logs in. We need to modify that&#xA;command to run the Go tests from our library. The good thing is that Hyprland&#xA;configuration file supports a&#xA;&lt;a href=&#34;https://wiki.hyprland.org/Configuring/Keywords/#executing&#34;&gt;&lt;code&gt;exec-once&lt;/code&gt;&lt;/a&gt;&#xA;command that runs a command during Hyprland launch. We can abuse this to launch&#xA;a terminal emulator and run our tests:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  programs.bash.loginShellInit =&#xA;    let&#xA;      testScript = pkgs.writeShellScript &amp;quot;hyprland-go-test&amp;quot; &#39;&#39;&#xA;        set -euo pipefail&#xA;&#xA;        trap &#39;echo $? &amp;gt; $HOME/test-finished&#39; EXIT # creates the canary when the script finishes&#xA;&#xA;        cd ${./.} # go to the library directory&#xA;        go test -v ./... &amp;gt; $HOME/test.log 2&amp;gt;&amp;amp;1 # run Go tests&#xA;      &#39;&#39;;&#xA;      hyprlandConf = pkgs.writeText &amp;quot;hyprland.conf&amp;quot; &#39;&#39;&#xA;        exec-once = kitty sh -c ${testScript}&#xA;      &#39;&#39;;&#xA;    in &#39;&#39;&#xA;      Hyprland --config ${hyprlandConf}&#xA;    &#39;&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So we are basically creating a custom Hyprland config that starts a&#xA;&lt;a href=&#34;https://sw.kovidgoyal.net/kitty/&#34;&gt;Kitty&lt;/a&gt; terminal emulator, that then launches&#xA;a shell script that runs the test. Since we have no way to get the results of&#xA;the test, we pipe the output to a file that we can collect later (e.g.:&#xA;&lt;code&gt;machine.succeded(&amp;quot;cat /home/alice/test.log&amp;quot;)&lt;/code&gt;). And once the script exit, we&#xA;create the canary file &lt;code&gt;$HOME/test-finished&lt;/code&gt;, that allows the &lt;code&gt;testScript&lt;/code&gt;&#xA;knows that the test finished and it can destroy the VM safely.&lt;/p&gt;&#xA;&lt;p&gt;If you want to take a look at the final result, it is&#xA;&lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/blob/v0.0.1/flake.nix&#34;&gt;here&lt;/a&gt;. This&#xA;tests run in any Linux machine that supports KVM, and also works in &lt;a href=&#34;https://github.com/thiagokokada/hyprland-go/actions/workflows/nix.yaml&#34;&gt;GitHub&#xA;Actions&lt;/a&gt;&#xA;thanks to the the&#xA;&lt;a href=&#34;https://github.com/DeterminateSystems/nix-installer-action&#34;&gt;nix-installer-action&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;And now I have a proper CI pipeline in a way that I never imagined would be&#xA;possible, especially considering how simple it was.&lt;/p&gt;&#xA;</description>
      <guid>https://github.com/thiagokokada/blog/blob/main/2024-07-26/01-writing-nixos-tests-for-fun-and-profit.md</guid>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>